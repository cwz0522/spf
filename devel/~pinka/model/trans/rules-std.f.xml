<?xml version="1.0" ?>
<f:forth xmlns:f="http://forth.org.ru/ForthML/"
  xmlns="http://forth.org.ru/ForthML/Rules/"
xmlns:r="http://forth.org.ru/ForthML/Rules/"
>
<!-- Apr.2007 ruvim@forth.org.ru -->
<!-- $Id$ -->

<rule match="f:xt"><!-- only within f:def or f:p -->
  <m>
  <f:lit> BFW, <f:p><yield/></f:p> RFW </f:lit>
  </m>
</rule>

<rule match="f:ahead"><m>
  <direct>BFW,</direct><yield/><direct>RFW</direct>
  </m>
</rule>

<rule match="r:m0">
  M @ >R  M 0!  <yield/>  R> M !
</rule>

<rule match="r:mm"><!-- in addition to 'r:m' -->
  <m>
  <f:choose> STATE? <f:when>
    <m0> INC-M <yield/> DEC-M </m0>
  </f:when><f:otherwise>
    <yield/>
  </f:otherwise></f:choose>
  </m>
</rule>

<f:def name="(yield-within-state)" ds=" state -- ">
  STATE @ >R STATE ! trans-childs R> STATE !
</f:def>

<f:def name="yield," ds=" -- ">
  STATE @ 0 EQ <f:if> -5006 THROW </f:if>
  STATE @ 1 EQ <f:if><postpone> trans-childs </postpone><f:exit/></f:if>
  <postpone><f:lit> STATE @ 1- </f:lit> (yield-within-state) </postpone>
</f:def>

<rule match="r:yield"><!-- because of r:mm -->
  <!-- only within non-nested r:rule -->
  yield,
</rule>

<f:cell name="q-s0"/>

<f:def name="q-prol">
  q-s0 @ >CS STATE0? q-s0 !
  <f:choose> q-s0 @ <f:when>
    CONCEIVE STATE 1+!
  </f:when> M @ 0EQ <f:when>
    <m><direct>BFW, CONCEIVE</direct></m>
  </f:when><f:otherwise>
    <f:lit>GERM</f:lit> EXEC,
  </f:otherwise></f:choose>
</f:def>

<f:def name="q-epil">
  <f:choose> q-s0 @ <f:when>
    STATE 1-! BIRTH
  </f:when> M @ 0EQ <f:when>
    <m><direct>BIRTH RFW LIT,</direct></m>
  </f:when><f:otherwise>
    <f:lit>GERM</f:lit> EXEC,
  </f:otherwise></f:choose>
  CS> q-s0 !
</f:def>

<r:rule match="f:q" ds=" -- xt "><!-- 'quote' (seems better than 'xt') -->
  <!-- not within of the r:mm when using the r:yield (!!!) -->
  q-prol <r:yield/> q-epil
</r:rule>


<rule match="f:times"><mm>
  <f:repeat> DUP <f:while/> >R <yield/> R> 1- </f:repeat> DROP
  </mm>
</rule>

<rule match="f:d"><!-- dynamic binding (for native words only) -->
  FirstChildValue
  <f:repeat> WORD|TAIL 2>R DUP <f:while />
    T-SLIT <m> &amp; EXECUTE </m>
  2R>
  </f:repeat>
  2DROP RDROP RDROP
</rule>

<f:def name="t-child-slit">
  cnode firstChild <f:choose> DUP <f:when> nodeValue T-SLIT </f:when> 0 T-2LIT </f:choose>
</f:def>

<rule match="f:emit">
  t-child-slit <m>TYPE</m>
</rule>

<rule match="f:emit-line">
  t-child-slit <m>TYPE CR</m>
</rule>

<rule match="f:wordlist"><mm>
  WORDLIST GET-CURRENT >CS
  DUP SET-CURRENT ALSO CONTEXT !
  <yield/>
  CONTEXT @ <!-- wid -->
  CS> SET-CURRENT PREVIOUS
  <get-attribute name="name"/> 
  <f:choose> DUP <f:when>
    ROT DUP >R <f:p><f:lit/></f:p> NAMING
    LATEST R> CELL+ ! <!-- spf4; ref to wordlist's name -->
  </f:when>
    2DROP 
  </f:choose>
  </mm>
</rule>

<rule match="f:export"><!-- child of f:wordlist only -->
  <mm>
  CS@ GET-CURRENT >CS  SET-CURRENT
  <yield/>
  CS> SET-CURRENT
  </mm>
</rule>

<rule match="f:also"><!-- immediately effect! -->
  `wordlist GetAttribute &amp; EXECUTE ALSO CONTEXT !
  <yield/>
  PREVIOUS
</rule>

<rule match="f:definitions"><mm>
  GET-CURRENT >CS  CONTEXT @ SET-CURRENT
  <yield/>
  CS> SET-CURRENT
  </mm>
</rule>

<rule match="f:const"><mm>
  <yield/>
  <f:p><f:lit/></f:p><get-attribute name="name"/> NAMING-
  </mm>
</rule>

<rule match="f:cell">
  <f:choose> cnode firstChild <f:when><yield/></f:when><m>0</m></f:choose>
  <mm> HERE SWAP , <f:p><f:lit/></f:p> <get-attribute name="name"/> NAMING- </mm>
</rule>

<rule match="f:cell2">
  <f:choose> cnode firstChild <f:when><yield/></f:when><m>0 0</m></f:choose>
  <mm> ALIGN HERE 2 CELLS ALLOT DUP >CS 2! CS> <f:p><f:lit/></f:p> <get-attribute name="name"/> NAMING- </mm>
</rule>

<rule match="f:let"><mm><!-- ( x addr - ) -->
  DUP DUP @ 2>R !  <yield/>  R> R> !
  </mm>
</rule>


<!-- r: -->

<rule match="r:transform" ds=" -- ">
  STATE0? <f:unless> ABORT </f:unless>
  HERE 0 , DUP <f:p><f:lit/></f:p> <get-attribute name="name"/> NAMING-
  chain-current @ >R chain-current !
  <yield/>
  R> chain-current !
</rule>

</f:forth>

Вообще, каталог нуждается в рефакторинге, т.к.:
  -- некоторые имена файлов вызывают оскому :)
  -- смешан код различных баз (spf4 зависимый, и независимый).



----- Элемент r:next-match
Пока что, содержимое данного элемента — это fallback, т.е. код, который
выполняется если "неудачно" (следующий обработчик ненайден).


----- Элементы r:m vs r:mm

Код, отмеченный элементом r:m, подлежит макроподстановке в объектной форме
(а не в исходной). Если такой код содержит элементы управления потоком 
исполнения, то он не сможет быть применен в немедленной форме. Это ограничение
связанно с формой откладывания элементов управления.

Для того, чтобы обойти данное ограничение, введен альтернативный элемент r:mm.
Он порождает два варианта объектного кода: для отложенного применения и для
немедленного применения. См. пример использования r:mm в определении f:times,
которое работает как в немедленной форме, так и в отложенной [rules-std.f.xml].

Другой вариант обхода данного ограничения состоит в использовании
вспомогательных слов, которые принимают на вход цитату и скрывают в себе 
все управление потоком исполения (этакая инверсия). Пример для f:times
  <def name="EXECUTE-TIMES" ds=" i*x u xt -- j*x ">
    <rem> повторить u раз выполнение xt </rem> 
    >R <repeat> DUP <while/> R@ SWAP >R EXECUTE R> 1- </repeat> RDROP DROP
  </def>
  <r:rule match="f:times"><r:m><q><r:yield/></q> EXECUTE-TIMES </r:m></r:rule>
  <rem> тест:
    0 5 <times> 1 + DUP . </times> DROP
  </rem>
Но, тут в немедлеленной форме возникает побочный эффект -- 
запись цитаты в пространстве кода (считай, утечка ;)  Так что, такой подход
более применим при автоматическом управлении памятью.



Элементы, в определении которых использовано r:mm,
будучи использованны в определениях других элементов,
должны быть тоже в r:mm (в r:m вероятно работать не будет, зависит от).

Поэтому, имена-шаблоны name="..{..}.." должны быть внтури r:mm (или, совсем без них),
см. tpat.f.xml

О, еще: внутрь { ... } нельзя передавать параметры через стек возвратов, а только через стек даных
(а иначе совсем жирно было бы ;)




----- Qualified name (QName)
  -- имя: уточненное, квалифицированное, отнесенное к, специфицированное

  Популярный в sp-forth вариант: имя, уточненное именем словаря (в том числе, рекурсивно ;).
  Пример: voc::wordname или voc1::voc2::any-word-name

  Формальное определение синтаксиса в общем виде —
    qname ::= name | qname "::" name

  Практически же, все уточняющие имена должны разрешаться в слова, возвращающие wid —
    qname     ::= name      | qname-voc "::" name
    qname-voc ::= name-voc  | qname-voc "::" name-voc



  Слово I-QNATIVE (определенное в файле ./iword-qnative.f.xml) выполняет интерпретацию
  квалифицированного имени. В общий стек трансляции оно включается в определении
  T-NAME (транслировать имя).

  Вообще, можно было бы включить его в стек трансляции и через цепочку I-NATIVE (была бы
  косвенная рекурсия). Но, тогда не было бы способа найти в контексте имя "как есть",
  вне зависимости от того, как это имя составлено.


-----
T-NAME -- трансляция имени

  Вариант иерархии (стек трансляции имени)

     executable (native words)
       I-NATIVE   ( CONTEXT )
       I-QNATIVE  ( CONTEXT EXECUTE )

     LIT (numbers)
       I-LIT        ( BASE )
       I-HLIT-FORM
       I-CLIT-FORM
       I-QUOTED-FORM  ( CONTEXT EXECUTE )

     DLIT (numbers)
       I-DLIT-FORM  ( BASE )

     SLIT (strings)
       I-SLIT-FORM 


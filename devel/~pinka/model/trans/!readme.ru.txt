¬ообще, каталог нуждаетс€ в рефакторинге, т.к.:
  -- некоторые имена файлов вызывают оскому :)
  -- смешан код различных баз (spf4 зависимый, и независимый).




 од, омеченный элементом r:m, подлежит макроподстановке в объектной форме
(а не в исходной). ≈сли такой код содержит элементы управлени€ потоком 
исполнени€, то он не сможет быть применен в немедленной форме. Ёто ограничение
св€занно с формой откладывани€ элементов управлени€.

ƒл€ того, чтобы обойти данное ограничение, введен альтернативный элемент r:mm.
ќн порождает два варианта объектного кода: дл€ отложенного применени€ и дл€
немедленного применени€. —м. пример использовани€ r:mm в определении f:times,
которое работает как в немедленной форме, так и в отложенной [rules-std.f.xml].

ƒругой вариант обхода данного ограничени€ состоит в использовании
вспомогательных слов, которые принимают на вход цитату и скрывают в себе 
все управление потоком исполени€ (этака€ инверси€). ѕример дл€ f:times
  <def name="EXECUTE-TIMES" ds=" i*x u xt -- j*x ">
    <rem> повторить u раз выполнение xt </rem> 
    SWAP >R <repeat> R@ <while/> DUP >R EXECUTE R> RP@ 1-! </repeat> RDROP DROP
  </def>
  <r:rule match="f:times"><r:m><q><r:yield/></q> EXECUTE-TIMES </r:m></r:rule>
  <rem> тест:
    0 5 <times> 1 + DUP . </times> DROP
  </rem>
Ќо, тут в немедлеленной форме возникает побочный эффект -- на каждой итерации
запись цитаты в пространстве кода (считай, утечка ;)  “ак что, такой подход
более применим при автоматическом управлении пам€тью.



Ёлементы, в определении которых использовано r:mm,
будучи использованны в определени€х других элементов,
должны быть тоже в r:mm (в r:m веро€тно работать не будет, зависит от).

ѕоэтому, имена-шаблоны name="..{..}.." должны быть внтури r:mm (или, совсем без них),
см. tpat.f.xml

ќ, еще: внутрь { ... } нельз€ передавать параметры через стек возвратов, а только через стек даных
(а иначе совсем жирно было бы ;)

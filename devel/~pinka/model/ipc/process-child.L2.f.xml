<?xml version="1.0" encoding="ASCII"?>
<forth xmlns="http://forth.org.ru/ForthML/">

<slot>
  own-handles
  child-in
  child-out
  consumer-out
</slot>

<def name="open-filename"  ds=" d-txt-filename mode -- h ">
  OVER <unless> >R 2DROP `NUL R> </unless>
  CREATE-FILE-SHARED THROW HERITABLE-HANDLE
</def>

<def name="assume-filenames"  ds=" d-txt-in d-txt-out d-txt-err -- ">
  <rem> if filename is 0 length, "NUL" assumed </rem>
  TRUE own-handles!
  W/O open-filename  >R
  W/O open-filename  >R
  W/O open-filename  R> R>
    assume-handles-std
</def>

<def name="stderr" ds=" -- h ">
  H-STDERR ?DUP <if>
    <rem>
      This handle may not coincide with the inherited (or default) STDERR handle.
      Default handle may be 0 (for example, in service process).
    </rem>
    DUP-HANDLE-INHERITED THROW
    <exit/>
  </if>
  0. W/O open-filename <rem> NUL pseudo file</rem>
</def>     

<def name="use-pipes-simple"  ds=" -- ">
  TRUE own-handles!
  <rem> h-read h-write </rem>
  CREATE-PIPE-ANON THROW >R HERITABLE-HANDLE        <rem> in  </rem>
  CREATE-PIPE-ANON THROW SWAP >R HERITABLE-HANDLE   <rem> out </rem>
  stderr                                            <rem> err </rem>
    assume-handles-std
  R> child-out!
  R> child-in!
</def>

<def name="close-handles-own" ds=" -- ">
  own-handles <if>
    child-out close-handle 0 child-out!
    child-in  close-handle 0 child-in!
    FALSE own-handles!
  </if>
</def>

<handler event="cleanup" advice="before">
  close-handles-own
  0 consumer-out!
</handler>

<def name="clear" ds=" -- "><rem> redefinition </rem>
  close-handles-own
  clear
</def>

<def name="perform-simple-per" ds=" a-in u-in a-shell u-shell consumer-xt -- result ">
  consumer-out! commandline! use-pipes-simple create-process
    close-handles-std <rem> (!!!) </rem>
  <rem>( d-data ior )</rem>
  DUP <if> close-handles-own THROW </if> DROP
  <rem>( d-data )</rem>
  child-in WRITE-FILE THROW
  child-in CLOSE-FILE THROW 0 child-in!

  4050 ALLOCATED OVER >R <q ds=" a-buf u-buf -- ">
    <repeat> 2DUP child-out READOUT-FILE THROW DUP <while/> consumer-out EXECUTE </repeat>
    2DROP 2DROP
  </q> CATCH
  child-out CLOSE-FILE OVER <if> DROP 0 </if> 0 child-out! THROW
  R> FREE SWAP THROW THROW

  exitcode-sure
  <rem> the object is stayed without clear (!!!) </rem>
</def>


</forth>

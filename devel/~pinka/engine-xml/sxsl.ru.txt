Simple XSL

  язык дл€ простого определени€ сложных XSLT-шаблонов, требующих динамический контекст
  (в XSLT 1.x дл€ этого приходитс€ вручную передавать переменную параметром в каждый темплейт,
  в 2.0 решаетс€ через  Tunnel Parameters -- http://www.w3.org/TR/xslt20/#tunnel-params).

   роме того, позвол€ет вызывать темплейты просто тегом по имени, типа <name/>
  и делает правильную подстановку в случае разметки <name> any xml </name>.
  —тандартный арсенал XSLT тоже доступен, в своем xmlns:xsl.
  ѕримеры --  ~pinka/fml/src/*.sxsl.xml

  ѕрограммы, заданные на этом €зыке, транслируютс€ в обычный XSLT путем применени€ sxsl.xsl.

  —ледующий шаг -- DXSL, динамический XSLT, должен позвол€ть "динамически" формировать
  xpath в select, name в call-template, и т.п. ќчевидно, ему потребуетс€ 
  на один-два прохода больше :)


ќсобенности и ограничени€

  ¬ SXSL нет средств вычислить и подставить параметр в генерируемый темплейт 
  (например, значение name, в <xsl:call-template name=''/>).

  ѕока не поддерживаетс€ упрощенное описание выхода в SXSL (аналог TransformAlias в XSLT).

  »мена авто-вызываемых темплейтов и слова €зыка SXSL в одном пространстве имен
  (поэтому, не должны пересекатьс€ с def, yield, var, let, apply-templates, call-template).

  ѕолучаемый в результате трансл€ции xsl-шаблон зачастую будет требовать XSLT 2.0,
  т.к. в XSLT 1.0 есть скверные ограничени€, св€занные с лексической областью видимости имен,
  как то, -- внутри переменной нельз€ объ€вить переменную с именем, которое
  используетс€ снаружи этой переменной в том же темплейте.

  SXSL не поддерживает include -- сборку из частей,
  т.к. в XSLT 1.0 есть трудность с пор€дком следовани€ узлов из разных документов,
  -- на него никак нельз€ повли€ть и невозможно €вно задать (в 2.0 решаетс€ через sequence).
  ѕоэтому, стоит использовать предварительную сборку средствами XInclude или struct-pre.xsl
  перед отдачей потока на обработку by SXSL.


\ $Id$
<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="../notion/xhtml.xsl"?>
<book>
<!-- Apr.2008 ruvim@forth.org.ru — -->
<!-- $Id$ -->

<h2>fcomposition</h2>

<toc/>

<chapter id="intro"><title>Введение</title>
<p>
Целью данной работы, имеющей кодовое название «fcomposition», 
является отработка композиции и целевой сборки форт-системы.
Задача состоит в том, чтобы построить целевой транслятор,
не зависящий от деталей конкретной целевой форт-системы,
но принимающий эти детали на вход, как функция аргументы,
и порождающий целевую систему в <i>ее собственном виде</i>.
Для решения этой задачи надо провести целесообразную 
модуляризацию целевой системы в общем виде 
и согласовать внутреннии и внешнии интерфейсы.
</p><p>
В качестве примера, представим описание одного транслятора, порождающего p-код,
и описание второго транслятора, порождающего некоторый машинный код.
Тогда, наш целевой транслятор по описанию первого должен построить его в p-коде,
а по описанию второго построить его в машинном коде. Тоже самое касается 
внутренних форматов словарей, контекстов, и т.п.
</p>
</chapter>

<chapter id="lyrics"><title>Лирика (опущена)</title>
<p>Лирику про то, что как и почему выбрано в качестве базовых элементов — опустим. Приступим к поверхностному изложению фактов :)</p>
</chapter>

<chapter id="target"><title>Характеристики целевой системы</title>
<p>При отработке общей композиции, реализация деталей роли не играет.
Для простоты, целевая система (которая описана в каталоге <w><a href="trial/">trial</a></w>) сделана <i>макетной</i>: формат откладываемого кода и все основные слова форт-процессора наследуются от инструментальной системы — SPF4 (импортируемые слова перечисляются в элементах <w>tc:import</w>).
Тем не менее, собственные в системе реализуются: <a href="trial/storage.f.xml">хранилище</a> (с опционально совмещенными или разделенными пространствами кода и данных), библиотека работы со <a href="trial/strings.f.xml">строками</a>, <a href="trial/codegen.f.xml">кодогенератор</a> (задает формат откладываемого кода) и интерпретатор, включающий форматы списков слов и контекста поиска. Также, есть цикл <w>QUIT</w>. Система очень постфиксно-ориентированна, поэтому нет и никаких слов, заглядывающих вперед ;)
</p><p>
  Все слова разбиты по тематическим спискам, и, кроме того, еще все свалены кучей в список <w>FORTH-WL</w> в отладочных целях (см. результат от <w>VOCS</w> и <w>WORDS</w>); при включении одного слова в несколько списков, они все для экономии разделяют одну копию текста имени. Разбиение сделано, чтобы было проще отсечь в контексте необходимые лексиконы — в SPF4 это трудно сделать, т.к. все свалено в единственную кучу. Отсекать надо, когда подставляется другая релизация лексикона и надо быть уверенным, что ничего случайно не попало из штатной реализации.  
</p><p>
  <a href="../../../model/data/wordlist-plain.f.xml">Список слов</a> наследует от 
  <a href="../../../model/data/list-plain.f.xml">простого списка</a>, 
  и над списками слов доступны операции, определенные для простых списков. Базовое представление строки наследует от представления блока данных ( addr u ), и над строками доступны операции блоков данных.
  Контекст поиска (<a href="../../../model/data/scope.static.f.xml">scope</a>) является стеком 
  и определен над <a href="../../../model/data/zstack.L1.immutable.f.xml">z-стеком</a>.
</p>
</chapter>


<chapter id="bootstrapping"><title>Раскрутка</title>
<p>Сборка целевой форт-системы делается почти так же, как и <a href="http://en.wikipedia.org/wiki/Self-hosting#History">раскручивался Лисп</a> :)
</p><p>
В инструментальную систему загружается менеджер хранилища, кодогенератор и интерпретатор от целевой системы. Поверх них загружается транслятор от ForthML (метаФорт)<sup>*</sup>.
Далее, инициируется все необходимое, запускается ранее загруженный транслятор и в нем выполняется загрузка всей целевой системы. В результате, в хранилище оказывается целевая система в собранном виде и этот образ остается сохранить в исполняемый файл.
</p>
<p>Не слишком ли просто? Где же тут целевой транслятор? 
Загруженный экземпляр транслятора метаФорта<sup>*</sup> им по сути и является, т.к. порождает код в формате целевой системы. С формальной же точки зрения, вся операция сводится к функции TT, которая применяет аргумент к нему самому — <w>TT: t --> t(t)</w>, где <w>t</w> представляет собой целевую систему в исходном виде. 
Должно быть, в этой более сложной семантике и лежит отличие целевого от обычных компиляторов.
</p>
</chapter>



<chapter id="generator"><title>О целевом трансляторе</title>
<p>Ядро целевого транслятора описанно в файле <w><a href="tc-host.f.xml">tc-host.f.xml</a></w>. <small>Слово «host» в имени файла намекает на основу и на отношение хозяин-гость. Здесь  целевой транслятор — хозяин, и загружаемая целевая система является гостевой по отношению к нему.</small> Это ядро задает основные отношения между составляющими его модулями, определяя абстрактную структуру.
Заданные там <w>#storage</w>, <w>#codegen</w>, <w>#interpreter</w> — это и есть формальные параметры, определяющие детали целевой системы.
</p>
<p> Как оказалось, это ядро — самая маленькая и в тоже время самая сложная часть данной раскрутки. Основная трудность связанна с тем, что при воплощении модели этого ядра в контексте находятся как лексиконы инструментальной системы так и перекрывающие их лексиконы формируемой хост-системы, и надо отслеживать, чтобы нигде не произошло ошибочной подмены. 
</p><p>
При загрузке гостевой системы дело обстоит значительно проще: благодаря использованию метаФорта, в контексте доступны только уже созданные слова самой гостевой системы и ничего более! Это дает значительное упрощение по сравнению с раскруткой SPF4.
</p>
</chapter>
  

<chapter id="files"><title>Назначение файлов</title>
<style> dd { margin-bottom: 0.7em; } </style>
<dl>

<dt><w><a href="envir.f.xml">envir.f.xml</a></w></dt>
<dd>окружение для целевого транслятора, используемые библиотеки;</dd>

<dt><w><a href="tc-host.f.xml">tc-host.f.xml</a></w></dt>
<dd>целевой транслятор (по старинке «tc»);</dd>

<dt><w><a href="carcase.f.xml">carcase.f.xml</a></w></dt>
<dd>каркас целевой форт-системы, все крупные блоки (лексиконы) с разбивкой по словарям;</dd>

<dt><w><a href="model.f.xml">model.f.xml</a></w></dt>
<dd>ссылается на <w>model-trial.f.xml</w>;</dd>

<dt><w><a href="model-trial.f.xml">model-trial.f.xml</a></w></dt>
<dd>испытательный состав целевой макетной системы;</dd>

<dt><w><a href="trial/">trial/</a></w></dt>
<dd>конкретная реализация лексиконов целевой системы;</dd>

<dt><w><a href="import-words.f.xml">import-words.f.xml</a></w></dt>
<dd>импорт слов из инструментальной системы в целевую;</dd>

<dt><w><a href="quit.f.xml">quit.f.xml</a></w></dt>
<dd>простейший цикл <w>QUIT</w> в целевой системе;</dd>

<dt><w><a href="index.f.xml">index.f.xml</a></w></dt>
<dd>сборка и инициализация целевой системы;</dd>

<dt><w><a href="index.f">index.f</a></w></dt>
<dd>корневой скрипт: загрузка библиотек, целевого транслятора, сборка и запуск целевой системы;</dd>

</dl>
</chapter>

</book>

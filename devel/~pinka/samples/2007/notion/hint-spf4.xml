<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>
<book>
<!-- 2006-2007 ruvim@forth.org.ru -->
<!-- $Id$ -->

<h2>Параграфы на памятку</h2>

<toc/>

<chapter id="quit"><title>Интерактивная отладка</title>
<p>Слово QUIT позволяет включить интерактивный режим
прямо в необходимом контексте — и проверить 
состояние стека, объектов, порядок поиска, выполнить вручную
оставшуюся часть слова.
Если целевым является дочерний поток (нить), тогда
в основном потоке надо сделать <nobr>-1 PAUSE</nobr> и 
обеспечить запуск QUIT лишь в отлаживаемом потоке.
Бывает полезно запустить QUIT среди процесса трансляции
файла — для отладки в текущем (особо, если глубоком) порядке поиска, вместо того, чтобы потом
устанавливать его вручную.
</p>

<p>Замечание. Выйти из слова QUIT и отдать управление
дальше, в точку после его вызова — невозможно (стандартного способа нет).
Тем самым, оно сто&#769;ит своего имени.
</p>

</chapter>


<chapter id="scope"><title>Область видимости при EXPORT</title>
<p>Пример
<pre>MODULE: SomethingSupport
  INCLUDE core-implementation.f \ provide A
EXPORT
  : A action-before A action-after ;
  : B some-actions A ;
;MODULE
</pre></p>
<p>Здесь перекрывается обычный принцип <i>локальности</i>: в слове B будет использованно
не только что определенное слово A, а ранее определенное из словаря SomethingSupport,
т.к. именно этот словарь первый в порядке поиска (то бишь, на вершине стека контекста).
</p>

<p>Ошибка: полагать, что в новом определении будет использованно выше-определенное слово, когда это не так.</p>

</chapter>

<chapter id="homonym"><title>Слова-омонимы</title>

<p>Бывает очень трудно отловить ошибку, когда вместо
ожидаемого слова в определение попадает его омоним — совпадающее по имени
другое слово.</p>
<p>Иллюстрация. В некоторых реализациях OOP имя слова-сообщения и имя слова-обработчика совпадают
(естественно, они находятся в разных словарях).
Слово-сообщение ожидает на вершине объект и далее некоторые параметры,
а слово-обработчик ожидает только параметры (объект устанавливается косвенным образом).
С каким словом произойдет связывание при употреблении данного имени — определяется контекстом.
В такой ситуации, при <i>легкомысленном</i> обращении с контекстом нетрудно получить неверное связывание 
и очень непонятные глюки даже при интерактивной отладке.
</p>
</chapter>


<chapter id="heap"><title>Хип локален для потока</title>

<p>Функции работы с памятью (ALLOCATE, RESIZE, FREE)
обращаются к некоторому хипу (куче).
Но, у каждого потока свой хип; взять же блок памяти
у одного хипа, а отдать другому хипу — нельзя.
</p>

<p>Ошибка: выделить память в одном потоке, а освободить ее попросту в другом.</p>

</chapter>


<chapter id="dll"><title>Относительные ссылки на DLL</title>

<p>Для подключения DLL используется системная функция LoadLibrary.
При разрешении имени она ищет файл по абсолютному пути,
относительно бинарника, или в системных каталогах Windows.
</p>

<p>Ошибка: расположенный в новом месте бинарник, 
а ссылки на dll таковы, что они доступны лишь из старого места.</p>

</chapter>


<chapter id="spfbig"><title>Расширение форт-системы</title>

<p>Слово SAVE сохраняет форт-систему (по сути, базовое хранилище)
в новый исполнямый файл; при его запуске будут доступны все
слова, словари и данные, которые были созданы перед сохранением (кроме
временных словарей и тому подобных динамических структур).
Порожденная таким образом форт-система является расширенной и более
специализированной по отношению к родительской.
</p>

<p>Совет. Используйте расширенные версии системы,
делая сохранение после подключения необходимых библиотек (типа `spfbig.exe SAVE)
или даже после сборки ядра целевого приложения (типа `acTCP.exe SAVE), — 
<i>чтобы обеспечить</i> экономное свертывание и развертывание,
быстрый запуск и при этом оставить возможность модификации и эволюции приложения
(живые исходники).
</p>

<p>Фичи. Легко выделить необходимое из среды разработки:
это бинарник расширенной системы, внештатные динамически связываемые библиотеки (dll),
каталог с исходниками непосредственно программы. 
Не надо копировать все библиотеки, или кропотливо выбирать только
используемы (они уже выбраны и собраны в бинарник).
Остается возможность модификации — наиболее часто изменяемая
часть программы берется из исходников. Запуск быстрей,
чем из начального ядра, т.к. мегабайты библиотек
уже собраны.
</p>

</chapter>

</book>

<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>
<book>
<!-- 2006-2007 ruvim@forth.org.ru -->
<!-- $Id$ -->

<h2>Параграфы на памятку</h2>

<toc/>

<chapter id="quit"><title>Интерактивная отладка</title>
<p>Слово <w>QUIT</w> позволяет выйти в интерактивный режим
прямо в необходимом контексте — и проверить 
состояние стека, объектов, порядок поиска, выполнить вручную
оставшуюся часть слова.
Если целевым является дочерний поток (нить), тогда
в основном потоке надо сделать <w>-1 PAUSE</w> и 
обеспечить запуск <w>QUIT</w> лишь в отлаживаемом потоке.
Бывает полезно запустить <w>QUIT</w> среди процесса трансляции
файла — для отладки в текущем (особо, если глубоком) порядке поиска, вместо того, чтобы потом
устанавливать его вручную.
</p>

<p><b>Замечание.</b> Выйти из слова <w>QUIT</w> и отдать управление
дальше, в точку после его вызова — невозможно (стандартного способа нет).
Тем самым, оно сто&#769;ит своего имени.
</p>

</chapter>


<chapter id="scope"><title>Область видимости при EXPORT</title>
<p>Пример
<pre>MODULE: SomethingSupport
  INCLUDE core-implementation.f \ provide A
EXPORT
  : A action-before A action-after ;
  : B some-actions A ;
;MODULE
</pre></p>
<p>Здесь перекрывается обычный принцип <i>локальности</i>, — в слове <w>B</w> будет использованно
не только что определенное слово <w>A</w>, а ранее определенное из словаря <w>SomethingSupport</w>,
т.к. именно этот словарь первый в порядке поиска (то бишь, на вершине стека контекста).
</p>

<p><b>Ошибка:</b> полагать, что в новом определении будет использованно выше-определенное слово, когда это не так.</p>

</chapter>

<chapter id="homonym"><title>Слова-омонимы</title>

<p>Бывает очень трудно отловить ошибку, когда вместо
ожидаемого слова в определение попадает его омоним — совпадающее по имени
другое слово.</p>
<p><b>Иллюстрация.</b> В некоторых реализациях OOP имя слова-сообщения и имя слова-обработчика совпадают
(естественно, они находятся в разных словарях).
Слово-сообщение ожидает на вершине объект и далее некоторые параметры,
а слово-обработчик ожидает только параметры (объект устанавливается косвенным образом).
С каким словом произойдет связывание при употреблении данного имени — определяется контекстом.
В такой ситуации <i>легкомысленное</i> обращении с контекстом может привести к неверному связыванию 
и очень непонятным глюкам даже при интерактивной отладке.
</p>
</chapter>


<chapter id="heap-local"><title>Хип локален для потока</title>

<p>Функции работы с памятью (<w>ALLOCATE</w>, <w>RESIZE</w>, <w>FREE</w>)
обращаются к некоторому хипу (куче).
Но, у каждого потока свой хип; взять же блок памяти
у одного хипа, а отдать другому хипу — нельзя.
</p>

<p><b>Ошибка:</b> выделить память в одном потоке, а освободить ее попросту в другом.</p>

</chapter>

<chapter id="heap-corrupt"><title>Повреждение хипа</title>

<p>Повреждение хипа часто ведет к молчаливому падению форт-системы.
Особенно сбивает с толку то, что падает «на ровном месте»,
далеко от того места, где произошло само повреждение,
и не во всяком случае.
</p><p>
Вот, устаревшая величина MAX_PATH, или ошибка в описании структуры MSG,
 — и происходит <i>переполнение буфера</i> и повреждение хипа.
Память повреждается прямо внутри системных функций, 
за недостаточностью поданного буфера.
</p>

</chapter>

<chapter id="dll"><title>Относительные ссылки на DLL</title>

<p>Для подключения DLL используется системная функция <w>LoadLibrary</w>.
При разрешении имени она ищет файл по абсолютному пути,
относительно бинарника, или в системных каталогах Windows.
</p>

<p><b>Ошибка:</b> расположенный в новом месте бинарник, 
а ссылки на dll таковы, что они доступны лишь из старого места.</p>

</chapter>


<chapter id="spfbig"><title>Расширение форт-системы</title>

<p>Слово <w>SAVE</w> сохраняет форт-систему (по сути, базовое хранилище)
в новый исполнямый файл; при его запуске будут доступны все
слова, словари и данные, которые были созданы перед сохранением (кроме
временных словарей и тому подобных динамических структур).
Порожденная таким образом форт-система является расширенной и более
специализированной по отношению к родительской.
</p>

<p><b>Совет.</b> Используйте расширенные версии системы,
делая сохранение после подключения необходимых библиотек (типа <w>`spfbig.exe SAVE</w>)
или даже после сборки ядра целевого приложения (типа <w>`acTCP.exe SAVE</w>), — 
<i>чтобы обеспечить</i> экономное свертывание и развертывание,
быстрый запуск и при этом оставить возможность модификации и эволюции приложения
(живые исходники).
</p>

<p><b>Фичи.</b> Легко выделить необходимое из среды разработки:
это бинарник расширенной системы, внештатные динамически связываемые библиотеки (dll),
каталог с исходниками непосредственно программы. 
Не надо копировать все библиотеки, или кропотливо выбирать только
используемы (они уже выбраны и собраны в бинарник).
Остается возможность модификации — наиболее часто изменяемая
часть программы берется из исходников. Запуск быстрей,
чем из начального ядра, т.к. мегабайты библиотек
уже собраны.
</p>

</chapter>

</book>

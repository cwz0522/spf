<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>
<book>
<!-- 2006-2007 ruvim@forth.org.ru -->
<!-- $Id$ -->

<chapter id="quit"><title>Интерактивная отладка</title>
<p>Слово QUIT позволяет включить интерактивный режим
прямо в необходимом контексте — и проверить 
состояние стека, объектов, порядок поиска, выполнить вручную
оставшуюся часть слова.
Если целевым является дочерний поток (нить), тогда
в основном потоке надо сделать -1 PAUSE и 
обеспечить запуск QUIT лишь в отлаживаемом потоке.
Бывает полезно запустить QUIT среди процесса трансляции
файла — для отладки в текущем (особо, если глубоком) порядке поиска, вместо того, чтобы потом
устанавливать его вручную.
</p>

</chapter>


<chapter id="scope"><title>Область видимости при EXPORT</title>
<p>Пример <pre>
MODULE: SomethingSupport

INCLUDE core-implementation.f \ provide A

EXPORT

: A action-before A action-after ;

: B some-actions A ;

;MODULE
</pre></p>
<p>Здесь перекрывается обычный принцип <i>локальности</i>: в слове B будет использованно
не только что определенное слово A, а ранее определенное из словаря SomethingSupport,
т.к. именно этот словарь первый в порядке поиска (то бишь, на вершине стека контекста).
</p>

<p>Ошибка: полагать, что в новом определении будет использованно выше-определенное слово, когда это не так.</p>

</chapter>

<chapter id="homonym"><title>Слова-омонимы</title>

<p>Бывает очень трудно отловить ошибку, когда вместо
ожидаемого слова в определение попадает его омоним — совпадающее по имени
другое слово.</p>
<p>Иллюстрация. В некоторых реализациях OOP имя слова-сообщения и имя слова-обработчика совпадают
(естественно, они находятся в разных словарях).
Слово-сообщение ожидает на вершине объект и далее некоторые параметры,
а слово-обработчик ожидает только параметры (объект устанавливается косвенным образом).
С каким словом произойдет связывание при употреблении данного имени — определяется контекстом.
В такой ситуации, при <i>легкомысленном</i> обращении с контекстом нетрудно получить неверное связывание 
и очень непонятные глюки даже при интерактивной отладке.
</p>
</chapter>


<chapter id="heap"><title>Хип локален для потока</title>

<p>Функции работы с памятью (ALLOCATE, RESIZE, FREE)
обращаются к некоторому хипу (куче).
Но, у каждого потока свой хип; взять же блок памяти
у одного хипа, а отдать другому хипу — нельзя.
</p>

<p>Ошибка: выделить память в одном потоке, а освободить ее попросту в другом.</p>

</chapter>


<chapter id="dll"><title>Относительные ссылки на DLL</title>

<p>Для подключения DLL используется системная функция LoadLibrary.
При разрешении имени она ищет файл по абсолютному пути,
относительно бинарника, или в системных каталогах Windows.
</p>

<p>Ошибка: расположенный в новом месте бинарник, 
а ссылки на dll таковы, что они доступны лишь из старого места.</p>

</chapter>


</book>

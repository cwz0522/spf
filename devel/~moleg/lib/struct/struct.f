\ 05-06-2004 ~mOleg  структуры, юниты, функции

\ ───────────────────────────────────────────────────────────────────────────

\ Получить по номеру бита его маску
: ?BIT  ( N --> mask ) 1  SWAP LSHIFT ;

\ получить по номеру бита его инверсную маску
: N?BIT ( N --> mask ) ?BIT INVERT ;

16 CONSTANT #VOCS

\ ───────────────────────────────────────────────────────────────────────────

\ упрятываем все ненужное в словарь-свалку HIDDEN
MODULE: HIDDEN

   HERE RET, HERE SWAP - CONSTANT ret#

   \ убрать завершающий EXIT из определения
   : remove-ret 0 ret# - ALLOT ;

   \ переменная хранит предыдущее STATE
   0 VALUE prev-state

   \ исполняется в конце сбора битовой маски
   \ если в режиме исполнения, то маска просто оставляется на стеке
   \ в режиме компиляции сохраняется в определении в виде 32-бит литерала.
   : (verb) ( mask --> ? )
            prev-state DUP STATE !
            IF ] LIT,
               0 TO prev-state
             ELSE
            THEN PREVIOUS ;

\ ───────────────────────────────────────────────────────────────────────────
   \ промежуточное место для хранения имени слова
   CREATE RealName 255 ALLOT

   \ сохранить имя слова во временное хранилище
   : save ( Asc # --> ) RealName SWAP 2DUP + 0! CMOVE ;

   \ используется в F; и определяет поведение слова, собранного по F:
   : Using STATE @ IF COMPILE, ELSE EXECUTE THEN PREVIOUS ;

   \ сохранить имя, создать безымянное определение
   : (F:) ( ASC # --> ) save :NONAME ;

\ ───────────────────────────────────────────────────────────────────────────

   \ создали стек для сохранения текущего словаря
   CREATE (CURR)  #VOCS ALLOT              (CURR) 0!

   \ сделали указанный словарь текущим, старый сохранили на стеке (CURR)
   : this ( wid --> )
          GET-CURRENT
          (CURR) DUP 1+!
                 DUP @ CELLS + !
          SET-CURRENT ;

   \ сделали текущим словарем, словарь с вершины (CURR), то есть предыдущий
   \ текущий вернули на место. Стек (CURR) не переопустошается, верхнее
   \ значение нельзя извлечь. Скорее всего это будет FORTH.
   : last ( --> )
          (CURR) DUP @ CELLS + @
                     SET-CURRENT
          (CURR) 1 OVER @ 1- MAX SWAP ! ;

\ ───────────────────────────────────────────────────────────────────────────

   \ эта переменная определяет вложенность юнита или структуры
   VARIABLE chain   chain 0!

   \ определяет, вложен ли словарь
   : ?chain ( --> flag ) chain DUP @ SWAP 0! ;

   \ получить wid последнего определенного словаря
   : last-voc  ( --> wid ) VOC-LIST @ CELL+ ;

   \ сделать указанный словарь контекстным
   : with      ( wid --> ) ALSO CONTEXT ! ;

   \ сделать последний определенный словать текущим
   : enter     ( -- ) last-voc DUP with this ;

   \ выйти в предыдущий текущий словарь
   : leave     ( -- ) PREVIOUS last ;

   \ создать словарь, войти в него, сделать текущим
   : container ( --> ) VOCABULARY enter ;

   \ определить размер структуры с учетом того, что она может расти вниз
   \ или начинаться с отрицательного положения
   : ?Size ( disp disp --> size ) 2DUP MAX -ROT MIN - ;

\ ───────────────────────────────────────────────────────────────────────────

  \ отсюда все идет в главный словарь системы
  ALSO FORTH DEFINITIONS

   \ создать слово, открывающее определение.
   \ текст за именем пойдет в безымянное определение, на
   \ которое будет ссылаться слово с именем name.
   : F: ( | name --> ) NextWord (F:) ;

   \ закрывает определение, начатое по F:
   \ создает словарную статью с именем name, указанным после F:
   \ позволяет обращаться к словам во вложенных словарях с
   \ автоматическим выходом из вложенных словарей.
   : ;F ( addr --> )
        [COMPILE] ;
        RealName ASCIIZ> SHEADER IMMEDIATE
        LIT, POSTPONE Using RET, ; IMMEDIATE

   \ сообщает о логической вложенности юнита или структуры
   \ если не использовать это слово, то придется отслеживать контекст и
   \  корректировать необходимым количеством PREVIOUS
   : Sub ( --> ) -1 chain ! ;

   \ создать словарь с именем name, сделать его контекстным и текущим
   : Unit: ( | name --> )
           container ?chain ,
           IMMEDIATE
           DOES> DUP CELL+ @ IF ELSE ALSO THEN
                     @ CONTEXT ! ;

   \ выйти из текущего юнита, восстановить состояние CONTEXT, CURRENT
   : EndUnit ( --> ) leave ;

\ ───────────────────────────────────────────────────────────────────────────

   \ создать заголовок структуры
   : Struct: ( disp | name --> disp disp )
             DUP
             container ?chain , \ вложенность
             IMMEDIATE
             DOES> DUP CELL+ @ IF ELSE ALSO THEN
                   @ CONTEXT ! ;

   \ создание константы
   : const  ( n --> ) F: SWAP LIT, [COMPILE] ;F ;

   \ возвращает не только смещение относительно начала записи,
   \ но и размер этой записи
   : field  ( disp # --> base )
            2DUP + >R
            ( disp --> base # )
            F: -ROT SWAP LIT, POSTPONE + LIT, [COMPILE] ;F
            R> ;

   \ для определения поля произвольной длинны
   : record ( disp # --> end )
            OVER +
            SWAP F: SWAP LIT, POSTPONE + [COMPILE] ;F ;

   \ для определения полей фиксированных длинн
   : Zero[] 0 record ;  \ для определения union-ов так будет проще
   : Byte[] 1 record ;
   : Word[] 2 record ;
   : Cell[] CELL record ;

   \ зарезервировать место за полем без определенного значения
   \ !!! внимание, за описателем идет комментарий до конца строки
   : noname\ ( disp # --> end ) + [COMPILE] \ ;

   \ окончить описание структуры, создать имя \size, определяющее
   \ размер структуры
   : EndStruct ( displ dispu --> )
               \ создали имя /size, хранящее размер структуры
               ?Size S" /size" (F:) SWAP LIT, [COMPILE] ;F
               leave ;

\ ───────────────────────────────────────────────────────────────────────────

   \ работа с битовыми полями.
   : Funct: ( OR_mask | Name --> OR_mask )
            >R container ?chain , R@ , IMMEDIATE R>

            DOES> DUP CELL+ @ IF ELSE ALSO THEN
                  DUP @ CONTEXT !
                  8 + @

                  STATE @ IF TRUE TO prev-state [COMPILE] [ THEN  ;

   \ описание битовых масок
   :  Mask ( m m --> m ) :        LIT, POSTPONE OR  [COMPILE] ;  ;
   : -Mask ( m m --> m ) : INVERT LIT, POSTPONE AND [COMPILE] ;  ;
   : Bit   ( m n --> m ) : ?BIT   LIT, POSTPONE OR  [COMPILE] ;  ;
   : -Bit  ( m n --> m ) : N?BIT  LIT, POSTPONE AND [COMPILE] ;  ;
   \ перечисления
   : Enum  ( shift mask --> )
           : LIT, POSTPONE AND
             LIT, POSTPONE LSHIFT
             POSTPONE OR
           [COMPILE] ;  ;

   \ это слово указывает на то, что предыдущая маска или слово закрывают
   \ сборку маски. см. пример в конце. Можно использовать с любым определением
   \ созданным через : -- ;

   : Verb: ( --> ) remove-ret POSTPONE (verb) RET, ;


   \ закончить описание битовой маски.
   : EndFunct ( OR_mask --> )
              DROP
              leave ;

\ ───────────────────────────────────────────────────────────────────────────

  PREVIOUS
;MODULE

\EOF

\ пример создания битовых масок, работы с битовыми полями:
HEX
 F00 Funct: proba{
          3 Mask aaa
          4 Mask bbb
          9 -Bit ccc
          2 3 Enum ddd

         : } ; Verb:
  EndFunct

: first   proba{ aaa } . ;
: second  proba{ bbb } . ;
: thrid   proba{ aaa bbb } . ;
: fourth  proba{ ccc } . ;
: fifth   proba{ 5 ddd } . ;

\EOF

\ тестовая секция

 Unit: proba                  CR    ORDER
     F: hello ." hello" ;F

     Sub Unit: check          CR    ORDER

     F: hello ." bye!" ;F
     EndUnit                  CR    ORDER
 EndUnit                      CR    ORDER

\EOF
иногда нужно не просто выбрать слово из указанного словаря, а заставить
в результате исполнения слова сделать указанный словарь контекстным
одиним из вариантов может быть: [compile] unit в теле определения. Возможно,
что это не лучший выход, зато самый простой. Конечно можно придумать
какое-то слово, смысл и код которого мне ясен, а вот имя и цель не очень 8)


Итак, появилась новая возможность управлять словарями без лишних трудностей.
А именно, при создании словаря нет нужды делать его текущим и контекстным,
как это делалось ранее: ALSO vocName DEFINITIONS, а в конце: PREVIOUS
DEFINITIONS. Кроме того словари становятся IMMEDIATE, то есть в режиме
компиляции слово из словаря можно просто достать.

Какие отличия от MODULE: имеющихся в СПФ. Во-первых, на мой взгляд более удобно
использовать множественно вложенные словари:

        Unit: Azimuth
          Sub Unit: Go
              F: Left  ... ;F
              F: Right ... ;F
          EndUnit
        EndUnit

и тогда:

        Azimuth Go Left
        Altitude Go Up
Кстати мне больше нравится именно такой синтаксис, а не
        Azimuth::Go::Left
так как в силу опыта последнее воспринимается, как одно слово.
Да и быстрее получится, так как быстрее найдется слово из словаря,
чем слово по цепочке notfound.

---
работа с битовыми полями выглядит почти так же, как и со структурами,
но имеет некоторые отличия связанные с тем, что в одном поле может
одновременно устанавливаться и сбрасываться несколько бит. Из-за этой
особенности после упоминания имени битового поля (словаря, где оно
описано) на стек выкладывается общая маска поля (не смещение) и интерпретатор
переходит в режим исполнения, до тех пор, пока не встретит слово, помеченное
признаком Verb:, которое по сути является не столько признаком, сколько
способом окончить сборку маски оставить результат в теле определения.
Есть несколько видов описания битовых полей:
     - n Bit установить указанный бит в маске
     - n -Bit сбросить указанный бит в маске
     - x Mask установить указанные биты
     - x -Mask сбросить указанные биты    (маска задается в прямом виде)
     - s m Enum при использовании идентификатора, созданного по Enum
       полученное на стеке число будет обрезано по m маске и сдвинуто s
       раз влево, результат сдвига будет по OR сложен с базовой маской.
Это основные операции для работы с масками. Любые другие при необходимости
можно добавить. По идее указанного набора достаточно, чтобы реализовать
систему комманд простого процессора(с командами фиксированной длинны).


\ Автоматическое тестирование библиотек, кода. 
\ 14-10-2006 written by mOleg for SPF4.17 
\ -- слова, которых не хватает в СПФ 

\ то же что и : только имя приходит на вершине стека данных в виде строки 
\ со счетчиком:   S" name" S: код слова ; 
: S: ( asc # --> ) SHEADER ] HIDE ; 

\ берем очередную лексему до тех пор, пока не конец потока 
\ в случае окончания потока возвращаем 0 0 вместо строки и ее длинны 
\ полезная идея взята из СМАЛ32. 
: iNextWord ( --> asc # ) 
            NextWord 

            DUP IF EXIT ELSE 2DROP THEN 

            REFILL IF RECURSE   \ здесь можно было бы просто NextWord 
                    ELSE 0 0 
                   THEN ; 

\ зря этого слова нет в СПФ 
: IS POSTPONE TO ; IMMEDIATE 

\ --------------------------------------------------------------------------- 

\ все слова кроме интерфейсных прячем в отдельный словарь 
VOCABULARY tests 
           ALSO tests DEFINITIONS 

\ векторизация этих слов позволяет просто расширять набор инструментов 
USER-VECT is-delimiter 
USER-VECT action 

\ основной цикл 
: process ( --> ) 
          BEGIN iNextWord DUP WHILE 
                2DUP is-delimiter WHILE 
               action 
           REPEAT 2DROP EXIT 
          THEN CR ." test section not finished" CR ABORT ; 

\ можно сделать просто переменную, но мне хочется, чтобы тестирование 
\ производилось в том случае, если в текущем словаре найдено слово testing 
: ?testing ( --> flag ) 
      S" testing" GET-CURRENT SEARCH-WORDLIST 
      IF DROP TRUE 
       ELSE FALSE 
      THEN ; 

\ --------------------------------------------------------------------------- 

\ имя, которое оканчивает тестовую секцию 
: test-delimiter  ( --> asc # ) S" ;test" ; 

\ так быстрее, чем каждый раз искать в словарях ограничитель через SFIND 
: is-test-delimiter ( asc # --> false|nfalse ) test-delimiter COMPARE ; 

\ а это другая альтернатива 8) 
: work-delimiter    ( --> asc # ) S" ;work" ; 
: is-work-delimiter ( asc # --> false|nfalse ) work-delimiter COMPARE ; 

\ --------------------------------------------------------------------------- 

        PREVIOUS DEFINITIONS 
                 ALSO tests 

\ во время тестирования весь текст между ограничителями интерпретируется 
\ или пропускается. 
\ Можно использовать внутри определений! 
: test: ?testing IF    ['] EVAL-WORD IS action 
                  ELSE ['] 2DROP IS action 
                 THEN 
        ['] is-test-delimiter IS is-delimiter 
        process ; IMMEDIATE 

\ если ограничитель встречен во входном потоке, то значит по каким-то 
\ причинам пропущено начало секции тестирования 
test-delimiter S: CR ." testing delimiters unpaired!" ABORT ; IMMEDIATE 

\ проходят действия обратные тестированию, то есть во время тестирования 
\ данная секция выполняться не будет! но в другое время будет. 
: work: ?testing IF    ['] 2DROP IS action 
                  ELSE ['] EVAL-WORD IS action 
                 THEN 
        ['] is-work-delimiter IS is-delimiter 
        process ; IMMEDIATE 

work-delimiter S: CR ." working delimiters unpaired!" ABORT ; IMMEDIATE 

        PREVIOUS 

\EOF                     ДЛЯ ЧЕГО ЭТО НАДО 

        Я предлагаю в каждую библиотечку вставлять код для автоматической 
 проверки ее работоспособности. Таким образом можно автоматически проверять 
 работоспособность всех библиотек, входящих в дистрибутив СПФа, да и самого 
 СПФа. Соответственно придется написать скрипт, который будет перебирать 
 все либы в .\devel\~??? и автоматически их подключать. Ошибка же себя сразу 
 покажет 8). К тому же данный подход можно использовать для автоматической 
 генерации версий кода, различных алгоритмов. 
 Ну и много других применений можно найти. 

        Место в котором будет проводиться тестирование, а так же состояние 
 переменной state не влияет на работоспособность процесса. То есть можно 
 вставлять пары tеst: ;tеst и внутрь определений, а можно использовать 
 отдельно для работы в режиме интерпретации. Вложение пар tеst: ;tеst не 
 предусматривается так как в отличие от СМАЛ32 у слов нет признака immediatest, 
 но пары tеst wоrk могут чередоваться и быть вложенными друг в друга.
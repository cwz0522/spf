\ 2006-12-09

BASE @ HEX

\ коментарии ------------------------------------------------------------------

\ для вывода сообщения о подключаемой секции
\ удобно использовать в начале файла
: \. 0x0A PARSE CR TYPE ;

\ коментарий до конца строки (для временного коментирования кусков кода)
: \? ( --> ) [COMPILE] \ ; IMMEDIATE

\ словари ---------------------------------------------------------------------

\ оставить в контексте только самый верхний словарь
: SEAL CONTEXT @ ONLY CONTEXT ! ;

\ заменить верхний контекстный словарь указанным
: WITH ( vid --> ) >R GET-ORDER NIP R> SWAP SET-ORDER ;

\ удалить верхний словарь с вершины контекста, следующий за ним
\ сделать текущим.
: RECENT ( --> )
         GET-ORDER 1 -
           DUP IF NIP OVER SET-CURRENT SET-ORDER
                ELSE DROP
               THEN ;

\ перенести vid словаря с вершины контекста в CURRENT
: THIS ( --> ) CONTEXT @ SET-CURRENT PREVIOUS ;

\ стековые манипуляции --------------------------------------------------------

\ поменять значения данных на вершине стека со значением переменной
: change ( n addr --> [addr] ) DUP @ -ROT ! ;

\ вычислить границы массива заданного своим адресом и длинной
: bounds ( addr # --> up low ) OVER + SWAP ;

\ опустить три значения со стека данных
: 3DROP ( n n n --> ) 2DROP DROP ;

\ удалить с вершины стека указанное число параметров
: nDROP ( [ .. ] n --> ) 1+ CELLS SP@ + SP! ;

\ логические операции ---------------------------------------------------------

\ Получить по номеру бита его маску
: ?BIT  ( N --> mask ) 1  SWAP LSHIFT ;

\ получить по номеру бита его инверсную маску
: N?BIT ( N --> mask ) ?BIT INVERT ;

\ парсер ----------------------------------------------------------------------

\ слово откатывает >IN назад, на начало непонятого слова
: <back ( ASC # --> ) DROP TIB - >IN ! ;

\ пропустить один символ во входном потоке
: SkipChar ( --> )  >IN @ 1 CHARS + >IN ! ;

\ вернуть адрес и длинну еще не проинтерпретированной части входного буфера.
: REST ( --> asc # ) SOURCE >IN @ DUP NEGATE D+ 0 MAX ;

\ вывод -----------------------------------------------------------------------

\ преобразовать число в символ
: >DIGIT ( N --> Char ) DUP 0x0A > If 7 + Then 30 + ;

\ добавить пробел в PAD 
: BLANK ( --> ) BL HOLD ;

\ добавить указанное кол-во пробелов в PAD 
: BLANKS ( n --> ) 0 MAX BEGIN DUP WHILE BLANK 1 - REPEAT DROP ;

\ распределение пространства форт системы -------------------------------------

\ резервировать на HERE n байт памяти, заполнить их байтом char
: AllotFill  ( n char --> ) HERE OVER ALLOT -ROT FILL ;

\ резервировать на HERE n байт памяти, заполнить их нулями
: AllotErase ( n --> ) 0 AllotFill ;


BASE !

\ Замыкания или частично определённые функции.
\ Функция задаётся строкой, которая компилируется в кучу. 
\ При откате занятая функцией область в куче снимается.

\ S" 2 DUP * ." axt ( xt ) -- выдаст на стек адрес кода
\ который соответсвует коду получившемуся при компиляции
\ строки

\ Взятый таким образом отрезок кода необходимо снимать
\ словом DESTROY-VC из ~profit/lib/compile2Heap.f

\ Чтобы снимать отрезок кода автоматически, при выходе 
\ из текущего определения (или при поднятии "из глубины"
\ bac4th-успеха) можно использовать axt=>
\ S" 2 DUP * ." axt=> ( xt )

\ Возможно также отрезок кода задать в несколько строк
\ через динамические строки ~ac/lib/str5.f
\ (со снятием памяти):
\ " 2 DUP
\ * . " straxt=> ( xt )

\ При этом в генерируемый отрезок кода кода можно скомпилировывать
\ свои куски, задавая их на стеке и выполняя компилирующией действия
\ IMMEDIATE-словами подобными LITERAL , оно нужно для передачи числа
\ на стеке в компилируемую функцию.
\ Или же можно входить напрямую в режим интерпретации словами [ и ] 
\ (см. примеры внизу)

\ Такая передача значений, внутрь "замыкания", противоречит
\ следующему абзацу пункта 3.2.3.2 ANS-94:

\ "Стек потока-управления, может, но не обязательно, физически 
\ существовать в реализации. Если он существует, то может быть,
\ но не обязательно, реализован с использованием стека данных.
\ Формат стека потока-управления -- определяется  реализацией.
\ Так как стек потока-управления  может быть реализован с 
\ использованием стека данных, элементы, помещенные на стек 
\ данных недоступны для программ после помещения элементов
\ на стек потока-управления, и остаются недоступным до удаления 
\ элементов стека потока-управления."

\ REQUIRE MemReport ~day/lib/memreport.f

REQUIRE /TEST ~profit/lib/testing.f
REQUIRE CONT ~profit/lib/bac4th.f
REQUIRE FREEB ~profit/lib/bac4th-mem.f
\ REQUIRE EVALUATED-HEAP ~profit/lib/evaluated.f
REQUIRE VC-COMPILED ~profit/lib/compile2Heap.f
REQUIRE STR@ ~ac/lib/str4.f
REQUIRE A_BEGIN ~mak/lib/a_if.f

MODULE: bac4th-closures

\ Используем структуры управления с отдельным control-flow stack
: BEGIN [COMPILE] A_BEGIN ; IMMEDIATE
: WHILE	[COMPILE] A_WHILE ; IMMEDIATE
: AHEAD	[COMPILE] A_AHEAD ; IMMEDIATE
: IF 	[COMPILE] A_IF ; IMMEDIATE
: ELSE	[COMPILE] A_ELSE ; IMMEDIATE
: THEN	[COMPILE] A_THEN ; IMMEDIATE
: AGAIN	[COMPILE] A_AGAIN ; IMMEDIATE
: REPEAT [COMPILE] A_REPEAT ; IMMEDIATE
: UNTIL [COMPILE] A_UNTIL ; IMMEDIATE

EXPORT

: axt ( addr u -- xt ) LOCAL t
CREATE-VC t ! \ создаём виртуальный кодофайл
ALSO bac4th-closures \ подключаем словарь с своими структурами управления
t @ VC-COMPILED \ компилируем строку в виртуальный кодофайл
PREVIOUS \ отключаем его по окончании компиляции
t @ VC-RET, \ ставим команду выхода
t @ \ берём исполняемый адрес начала кодофайла
;


: axt=> ( addr u --> xt \ <-- ) PRO
axt \ компилируем строку, берём исполняемый адрес кода
BACK DESTROY-VC TRACKING RESTB \ по окончании обработки очистить кодофайл
CONT \ и кидаем его наверх
;

\ То же самое что и compiledCode , но с динамическими строками из ~ac/lib/str4.f
\ Это позволяет писать код в несколько строк
: straxt=> ( s --> xt \ <-- ) PRO LOCAL s DUP s ! STR@ axt=> s @ STRFREE CONT ;

: compiledCode ( addr u --> xt \ <-- ) \ синоним для axt=>
RUSH> axt=> ;

: STRcompiledCode  ( s --> xt \ <-- ) RUSH> straxt=> ;

;MODULE

/TEST
REQUIRE SEE lib/ext/disasm.f

: showMeTheCode ( addr u -- ) compiledCode XT-VC DUP REST EXECUTE CR CR ;

$> 4 2 1 S" LITERAL LITERAL + LITERAL * ." showMeTheCode

$> 100 S" 0 BEGIN DUP 10 < WHILE LITERAL . 1+ REPEAT DROP " showMeTheCode
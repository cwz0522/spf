Особенности SPF
===============

Этот файл - краткое вступление в SPF для тех, кто уже знаком с Фортом.
Цель - ввести в курс особенностей SPF4.

Последнее обновление: $Date$

----

<a id="toc"/>
##Содержание

* [Установил SPF4. И где здесь что-куда?](#devel)
* [Оптимизатор](#opt)
* [Как запускать и подключать файлы?](#include)
* [REQUIRE](#require)
* [Модули](#module)
* [Регистро-зависимость](#case)
* [Ввод чисел](#numbers)
* [Где FORGET?](#forget)
* [Как одним словом очистить стек?](#cls)
* [Комментарии](#comments)
* [Строки](#string)
* [Генерация исполняемых модулей (exe-файлов)](#save)
* [Локальные и временные переменные](#locals)
* [Подключение dll-библиотек](#dll)
* [Слово NOTFOUND](#notfound)
* [Scattered colons](#scatcoln)
* [Многозадачность](#task)
* [Словари](#voc)

----
<a id="devel"/>
###[Установил SPF4. И где здесь что-куда?][toc]

Первое и самое важное -- расположение ваших рабочих файлов. В дистрибутиве SPF
есть папка DEVEL, предназначенная для разработчиков (в том числе и вас).
Создайте в ней вашу папку, например, ~vasya. И теперь вы можете подключать ваши
файлы написав сокращённый путь в виде ~vasya/prog/myprog.f. Это упрощает
взаимный доступ к библиотекам и программам. Общепринято библиотеки ложить в
подкаталог lib, а примеры программ в prog.

В папке DEVEL собраны наработки других SP-Forth'еров, с кратким (очень
кратким) их обзором вы можете ознакомиться по адресу:
<http://wiki.forth.org.ru/SPF_DEVEL>, либо пройтись по папке самому.


----
<a id="opt"/>
###[Оптимизатор][toc]

SPF - форт-система с подпрограммным шитым кодом, то есть компиляция проходит
сразу в исполняемый код в виде цепочек `CALL <адрес-cfa-слова>`. Это код можно
запускать и непосредственно, но в системе по-умолчанию есть ещё и оптимизатор, 
который обрабатывает машкод для большего быстродействия, выполняя
inline-подстановку и peephole-оптимизацию. Подробнее на [Вики][opt].

**NB**: Если вдруг ваша программа начинает выкидывать неожиданные фортели -
отключите временно оптимизатор словом `DIS-OPT` (включается обратно -
`SET-OPT`), есть вероятность (очень маленькая!), что это может быть баг в
оптимизаторе. Если это так - локализуйте его и отправьте автору. 

[opt]: http://wiki.forth.org.ru/оптимизирующий%%20компилятор

Результат компиляции слова в виде машинного кода можно посмотреть вручную с
помощью дизассемблера:

	REQUIRE SEE lib\ext\disasm.f
	SEE слово

или получить построчный листинг

	REQUIRE INCLUDED_L ~mak/listing2.f
	S" файл машкод которого хотим посмотреть"  INCLUDED_L
	\ листинг будет лежать рядом с подключаемым файлом


----
<a id="include"/>
###[Как запускать и подключать файлы?][toc]

Если просто набрать путь файла в SPF он поймёт что это файл:
	~vasya/prog/myprog.f
В целях совместимости лучше подключать явно:
	S" ~vasya/prog/myprog.f" INCLUDED
Но правильнее всего использовать `REQUIRE`



----
<a id="require"/>
###[REQUIRE][toc]

В SPF есть нестандартное слово `REQUIRE` со следующим синтаксисом:
	REQUIRE "word" "file"
, где `word` - это слово которое определяется в файле `file`. Если оно уже
существует `REQUIRE` считает что библиотека уже была подключена и не загружает её.
Так избегается двойная загрузка библиотек.
Например:
	REQUIRE CreateSocket ~ac/lib/win/winsock/sockets.f
	REQUIRE ForEach-Word ~pinka/lib/words.f
	REQUIRE ENUM ~nn/lib/enum.f



----
<a id="module"/>
###[Модули][toc]

В SPF есть модули, которые позволяют скрывать некоторые внутренние слова
библиотек выводя наружу только слова для взаимодействия.
	MODULE: vasya-lib
	\ внутренние слова
	EXPORT
	\ слова взаимодействия, видные снаружи, компилируются во внешний словарь.
	DEFINITIONS
	\ опять внутренние слова
	EXPORT
	\ ну вы поняли :)
	;MODULE
Код `MODULE: vasya-lib` можно писать много раз - последующие вызовы будут
докомпилировать слова в тот же модуль. На самом деле `MODULE:` это обычный
[словарь](#voc).



----
<a id="case"/>
###[Регистро-зависимость][toc]

SPF регистрозависим, то есть в этом режиме для него слова CHAR , Char и char -
три разных слова. Этот режим можно выключить подключением файла
`lib\ext\caseins.f`.



----
<a id="numbers"/>
###[Ввод чисел][toc]

SPF позволяет вводить шестнадцатиричные числа вне зависимости от текущей системы
счисления (значения переменной `BASE`) так: 
	0x7FFFFFFF
Вещественные числа можно вводить в формате [+|-][dddd][.][dddd]e[+|-][dddd]
подключив либу `lib/include/float2.f`.



----
<a id="forget"/>
###[Где FORGET?][toc]

`FORGET` нет. Но есть `MARKER ( "name" -- )` (в `lib\include\core-ext.f` или в `~clf/marker.f`).



----
<a id="cls"/>
###[Как одним словом очистить стек?][toc]

Наберите lalala. Или bububu. Или лялятополя. Возникнет ошибка и стек сбросится.
На самом деле стек сбросит слово `ABORT`, которое будет вызвано если интерпретатор
не найдёт введённое слово.

__В FAQ__



----
<a id="comments"/>
###[Комментарии][toc]

В SPF есть комментарии до конца строки ` \ `. Есть и обычные, скобочные, комментарии,
которые к тому же ещё и многострочные. То есть:

	\ комментарий до конца строки
	( комментарий
	и даже в несколько строк )
Есть слово `\EOF` которое делает комментарием всё идущее после него в файле. Таким
образом удобно отделять примеры использования библиотеки от самой библиотеки.

	word1 word2
	\EOF
	комментарий до конца файла



----
<a id="string"/>
###[Строки][toc]

В SPF в основном используются строки со счётчиком на стеке - т.е. два значения
`(addr u)`. Для удобства работы с WinAPI в конец строки добавляется 
нулевой байт.



----
<a id="save"/>
###[Генерация исполняемых модулей (exe-файлов)][toc]

Слово `SAVE ( a u -- )` сохраняет всю форт-систему, включая все словарные
структуры (кроме временных!) в исполняемый модуль путь к которому задаётся
строкой `a u`.



----
<a id="locals"/>
###[Локальные и временные переменные][toc]

Не входят в ядро, но подключаются:

	REQUIRE { lib/ext/locals.f
	\ пример простого использования
	: test { a b | c d }  \ a b инициализируюся со стека, c и d нулями
	  a -> c
	  b TO d
	  c . d . ;
	1 2 test
	>1 2
	> Ok
Подробное описание и примеры использования смотрите в самой библиотеке.



----
<a id="dll"/>
###[Подключение dll-библиотек][toc]

Пример:
	WINAPI: SevenZip 7-zip32.dll
Если нужно подключить все функции из dll-файла то можно использовать:
	UseDLL "имя_библиотеки" \ либа ~nn/lib/usedll.f
	DLL NEW: "имя_библиотеки" \ либа ~ac/lib/ns/dll-xt.f


----
<a id="notfound"/>
###[Слово NOTFOUND][toc]

Если во время цикла INTERPRET не будет
найдено очередное слово из входного потока - в текущем словаре ищется и
вызывается слово `NOTFOUND ( a u -- )`. Если `NOTFOUND` не обрабатывает данное
слово - он должен вывалиться с исключением. Иначе считается, что слово
воспринято и трансляция продолжается. По умолчанию через NOTFOUND реализовано
распознавание чисел, и доступ к вложенным словарям в виде
	vocname1:: wordname
Правило хорошего тона - при переопределении `NOTFOUND` сначала вызвать его
старый вариант, и если он не отвалится по исключению - выполнять свои
действия. Пример :
	 : MY? ( a u -- ? ) S" !!" SEARCH >R 2DROP R> ;
	 : DO-MY ( a u -- ) ." My NOTFOUND: " TYPE CR ;

	 : NOTFOUND ( a u -- )
	   2DUP 2>R ['] NOTFOUND CATCH 
	   IF
	     2DROP
	     2R@ MY? IF 2R@ DO-MY ELSE -2003 THROW THEN
	   THEN
	   RDROP RDROP
	   ;
Или так :
	 : NOTFOUND ( a u -- )
	   2DUP MY? IF DO-MY EXIT THEN
	   ( a u )
	   NOTFOUND
	   ;


----
<a id="scatcoln"/>
###[Scattered colons][toc]

Расширяемые слова. 
	: INIT ... do1 ; 
	\ если вызвать INIT здесь то выполнится do1
	..: INIT do2 ;.. 
	\ если здесь - то do1 и do2
	..: INIT do3 ;.. 
	\ и так далее
По технологии scattered colons в SPF реализованы слова `AT-THREAD-STARTING` и
`AT-PROCESS-STARTING`, которые вызываются при старте потока и при старте
процесса соответственно. Например библиотека `lib/include/float2.f` добавляет в
`AT-THREAD-STARTING` действия по инициализации внутренних переменных.



----
<a id="task"/>
###[Многозадачность][toc]

Потоки создаются словом `TASK: ( xt -- task)` и запускаются словом 
`START ( u task -- tid )`, 
`xt` это исполнимый токен который получит управление при старте потока и
на стеке будет пользовательский параметр `u`. Возвращаемое значение `tid`
используется для остановки потока снаружи словом `STOP ( tid -- )`.
Приостановить поток на заданное время можно словом `PAUSE ( ms -- )`.
Пример :

	REQUIRE { lib/ext/locals.f

	:NONAME { u \ -- }
	   BEGIN
	   u .
	   u 10 * 100 + PAUSE
	  AGAIN
	; TASK: thread
	
	: go
	  10 0 DO I thread START LOOP
	  2000 PAUSE
	  ( tid1 tid2 ... tid10 )
	  10 0 DO STOP LOOP
	;

	go

Обычные переменные (`VARIABLE`,`VALUE`) будут разделять своё значение между
потоками. Если же переменная должна быть локальной для потока - следует
определять её словом `USER ( "name" -- )` или `USER-VALUE ( "name" -- )`.
USER-переменные при старте потока инициализируются нулём.


----
<a id="voc"/>
###[Словари][toc]

Словари создаются либо стандартным `VOCABULARY ( "name" -- )` 
либо словом `WORDLIST ( -- wid )`. 
Точнее, `WORDLIST` это более общее понятие - просто список слов. Есть
также слово `TEMP-WORDLIST ( -- wid)` создающее временный словарь, который по
окончании работы надо освободить из памяти словом `FREE-WORDLIST`, содержимое
временного словаря не попадёт в образ системы при использовании слова `SAVE`.
Слово `{{ ( "name" -- )` сделает словарь name контекстным, а слово `}}` вернёт как
было. Пример

	MODULE: my
	: + * ;
	;MODULE
	{{ my 2 3 + . }}
напечатает 6, а не 5.


[toc]: #toc

----
----

Особенности SPF
===============

<small><i>Краткое вступление для тех, кто уже знаком с какой-либо Форт-системой и/или
стандартом ANS'94.</i></small>

Последнее обновление: $Date$

----

<a id="toc"/>
##Содержание

* [Установил SPF4. И где здесь что-куда?](#devel)
* [Оптимизатор](#opt)
* [Поддержка ANS](#ans)
* [Как запускать и подключать файлы?](#include)
* [REQUIRE](#require)
* [Модули](#module)
* [Регистро-зависимость](#case)
* [Ввод чисел](#numbers)
* [Структуры](#struct)
* [Где FORGET?](#forget)
* [Как одним словом очистить стек?](#cls)
* [Средства отладки](#debug)
* [Комментарии](#comments)
* [Строки](#string)
* [Генерация исполняемых модулей (exe-файлов)](#save)
* [Локальные и временные переменные](#locals)
* [Подключение dll-библиотек](#dll)
* [Слово NOTFOUND](#notfound)
* [Scattered colons](#scatcoln)
* [Многозадачность](#task)
* [Словари](#voc)

----
<a id="devel"/>
###[Установил SPF4. И где здесь что-куда?][toc]

Первое и самое важное - расположение ваших рабочих файлов. В дистрибутиве SPF
есть папка DEVEL, предназначенная для разработчиков (в том числе и вас).
Создайте в ней вашу папку, например, ~vasya. И теперь вы можете подключать ваши
файлы написав сокращённый путь в виде `~vasya\prog\myprog.f`. Это упрощает
взаимный доступ к библиотекам и программам. Общепринято библиотеки класть в
подкаталог lib, а примеры программ в prog.

В папке DEVEL собраны наработки других SP-Forth'еров, с кратким (очень
кратким) их обзором вы можете ознакомиться по адресу:
<http://wiki.forth.org.ru/SPF_DEVEL>, либо пройтись по папке самому.


----
<a id="opt"/>
###[Оптимизатор][toc]

SPF - форт-система с подпрограммным шитым кодом, то есть компиляция проходит
сразу в исполняемый код в виде цепочек `CALL <адрес-cfa-слова>`. Это код можно
запускать и непосредственно, но в системе по-умолчанию есть ещё и оптимизатор, 
который обрабатывает машкод для большего быстродействия, выполняя
inline-подстановку и peephole-оптимизацию. Подробнее на ForthWiki:
"[Оптимизирующий компилятор](http://wiki.forth.org.ru/оптимизирующий%20компилятор)".

**NB**: Если вдруг ваша программа начинает выкидывать неожиданные фортели -
отключите временно оптимизатор словом `DIS-OPT` (включается обратно -
`SET-OPT`), есть вероятность (очень маленькая!), что это может быть ошибка в
оптимизаторе. Если это так - локализуйте её и отправьте автору. 

Результат компиляции слова в виде машинного кода можно посмотреть вручную с
помощью дизассемблера:

	REQUIRE SEE lib/ext/disasm.f
	SEE слово

или получить построчный листинг

	REQUIRE INCLUDED_L ~mak/listing2.f
	S" файл, машкод которого хотим посмотреть"  INCLUDED_L
	\ листинг будет лежать рядом с подключаемым файлом


----
<a id="ans"/>
###[Поддержка ANS][toc]

Максимального соответствия ANS'94 можно добиться подключив
`lib/include/ansi.f`. Там определяются дополнительные наборы слов, некоторые
заглушки и т. д.
Также исправляется неприятная особенность слов из ядра для
работы с файлами - `OPEN-FILE`, `CREATE-FILE` и другие слова неявно требуют строку
оканчивающуюся нулём, тогда как по стандарту получают строку со счётчиком на
стеке.


----
<a id="include"/>
###[Как запускать и подключать файлы?][toc]

В коммандной строке скормить файл SPF'у можно просто указав путь к нему в
параметрах запуска, 

	spf.exe ~vasya/prog/myprog.f
Заметьте, что путь для включения могут быть как абсолютным, так и
относительно каталога [devel](#devel).

В консоли SPF (в режиме интерпретации) достаточно набрать имя файла:

	~vasya/prog/myprog.f
В целях совместимости лучше подключать явно:

	S" ~vasya/prog/myprog.f" INCLUDED

Но правильнее всего использовать `REQUIRE`.


----
<a id="require"/>
###[REQUIRE][toc]

В SPF есть нестандартное слово `REQUIRE` со следующим синтаксисом:

	REQUIRE "word" "file"
, где `word` - это слово которое определяется в файле `file`. Если оно уже
существует, `REQUIRE` считает что библиотека уже была подключена и не загружает её.
Так избегается двойная загрузка библиотек.
Например:

	REQUIRE CreateSocket ~ac/lib/win/winsock/sockets.f
	REQUIRE ForEach-Word ~pinka/lib/words.f
	REQUIRE ENUM ~nn/lib/enum.f



----
<a id="module"/>
###[Модули][toc]

В SPF есть модули, которые позволяют скрывать некоторые внутренние слова
библиотек выводя наружу только слова для взаимодействия.

	MODULE: vasya-lib
	\ внутренние слова
	EXPORT
	\ слова взаимодействия, видные снаружи, компилируются во внешний словарь.
	DEFINITIONS
	\ опять внутренние слова
	EXPORT
	\ ну вы поняли :)
	;MODULE
Код `MODULE: vasya-lib` можно писать много раз - последующие вызовы будут
докомпилировать слова в тот же модуль. На самом деле слово определённое через
`MODULE:` это обычный [словарь](#voc).


----
<a id="case"/>
###[Регистро-зависимость][toc]

SPF регистрозависим, то есть в этом режиме для него слова `CHAR` , `Char` и `char` -
три разных слова. Этот режим можно выключить подключением файла
`lib/ext/caseins.f`.



----
<a id="numbers"/>
###[Ввод чисел][toc]

SPF позволяет вводить шестнадцатиричные числа вне зависимости от текущей системы
счисления (значения переменной `BASE`) так:
 
	0x7FFFFFFF
Вещественные числа можно вводить в формате `[+|-][dddd][.][dddd]e[+|-][dddd]`
подключив либу `lib\include\float2.f`.


----
<a id="struct"/>
###[Структуры][toc]

Структуры в SPF создаются через слово `--` (оно же `FIELD`). Пример:

	0
	CHAR -- flag
	CELL -- field
	10 CELLS -- arr
	CONSTANT struct

Слова `flag`, `field` и `arr` будут прибавлять к адресу своё смещение 
относительно начала структуры. А в `struct` записан общий размер
всей структуры. То есть, можно:

	struct ALLOCATE THROW TO s \ взяли память из кучи под один экземпляр struct
	1 s flag С!  10 s field ! \ записали значения в поля структуры
	s arr 10 CELLS DUMP \ вывели содержимое массива в структуре
	s FREE THROW \ сняли экземпляр struct

Структуры можно наследовать:

	0
	CELL -- x
	CELL -- y
	CONSTANT point \ у point два поля
	
	point
	CELL -- radius
	CONSTANT circle \ у circle три поля: x, y, radius
	
	point
	CELL -- w
	CELL -- h
	CONSTANT rect \ у rect четыре поля: x, y, w, h

----
<a id="forget"/>
###[Где FORGET?][toc]

`FORGET` нет. Но есть `MARKER ( "name" -- )` (в `lib\include\core-ext.f` или в `~clf/marker.f`).



----
<a id="cls"/>
###[Как одним словом очистить стек?][toc]

Наберите `lalala`. Или `bububu`. Или `лялятополя`. Возникнет ошибка и стек сбросится.
На самом деле стек сбросит слово `ABORT`, которое будет вызвано если интерпретатор
не найдёт введённое слово. Ну а на самом-самом деле - это делается так: `S0 @ SP!`

__В FAQ__


----
<a id="debug"/>
###[Средства отладки][toc]

Слово `STARTLOG` включает запись всего консольного вывода в лог-файл
`spf.log` в текущей папке. `ENDLOG` соответственно выключает такое поведение.


__Подробнее!__


----
<a id="comments"/>
###[Комментарии][toc]

В SPF есть комментарий до конца строки ` \ `. Есть и обычные, скобочные, комментарии,
которые к тому же ещё и многострочные. То есть:

	\ комментарий до конца строки
	( комментарий
	и даже в несколько строк )
Есть слово `\EOF` которое делает комментарием всё идущее после него в файле. Таким
образом удобно отделять примеры использования библиотеки от самой библиотеки.

	word1 word2
	\EOF
	комментарий до конца файла



----
<a id="string"/>
###[Строки][toc]

В SPF в основном используются строки со счётчиком на стеке - т.е. два значения
`(addr u)`. Для записи строковых литералов (строковых констант) используется
слово `S"`, которое в зависимости от текущего режима выполняет несколько разные
действия:

* В режиме интерпретации строка находится во временном текстовом буфере разбора (`TIB`),
и соответственно, работает только в пределах одной строки.

* В режиме компиляции строка вкомпилируется непосредственно в шитый код определяемого слова.

Для удобства работы с WinAPI в конец строк добавляется дополнительный, завершающий
нулевой байт.

Слово `S"` создаёт т. н. статическую строку, она находится или в буфере, или в словарной
структуре SPF. Для работы со динамическими строками, которые резервируются в "куче" и снимаются
оттуда есть библиотека `~ac\lib\str4.f`. Пример её использования:

	REQUIRE STR@ ~ac/lib/str4.f
	"" VALUE r \ создаём пустую строку
	" мама, мама, " VALUE m
	" что я буду делать?" VALUE w
	m r S+  w r S+
	r STYPE
	> мама, мама, что я буду делать?

Кроме конкатенации строк можно использовать и подстановку (в том числе и других строк):

	" 2+2={2 2 +}" STYPE
	> 2+2=4

Исчерпывающее описание и более подробные примеры см. в самой библиотеке.

Надо также заметить что в SPF поддерживается префикс слов `S-` и окончание `-ED`.

`S-` означает что слово работает со строками со счётчиком (например есть
`SFIND` и есть стандартный `FIND`, есть `SLITERAL` и `LITERAL`).

`-ED` есть в словах `CREATED`, `INCLUDED`, `REQUIRED`, `ALIGNED`. Он обозначает что это
слово, в отличии от своего "корня", будет ожидать параметров со стека, а не брать его из
входного потока (или из глобальной переменной, как в случае с `ALIGN` и `ALIGNED`).

Например, стандартный `CREATE` берёт свой параметр из входного потока, тогда как `CREATED`
явно забирает параметр со стека данных в виде начала строки и её длины.

----
<a id="save"/>
###[Генерация исполняемых модулей (exe-файлов)][toc]

Слово `SAVE ( a u -- )` сохраняет всю форт-систему, включая все словарные
структуры (кроме временных!) в исполняемый модуль путь к которому задаётся
строкой `a u`. То есть:

	S" myprog.exe" SAVE


----
<a id="locals"/>
###[Локальные и временные переменные][toc]

Не входят в ядро, но подключаются:

	REQUIRE { lib/ext/locals.f
	
	\ пример простого использования
	: test { a b | c d }  \ a b инициализируюся со стека, c и d нулями
	  a -> c
	  b TO d
	  c . d . ;
	1 2 test
	>1 2
	> Ok
Подробное описание и примеры использования смотрите в самой библиотеке.



----
<a id="dll"/>
###[Подключение dll-библиотек][toc]

Пример:

	WINAPI: SevenZip 7-zip32.dll
Если нужно подключить все функции из dll-файла то можно использовать
либо:

	REQUIRE UseDLL ~nn/lib/usedll.f
	UseDLL "имя_библиотеки"

или:

	REQUIRE DLL ~ac/lib/ns/dll-xt.f
	DLL NEW: "имя_библиотеки" 

----
<a id="notfound"/>
###[Слово NOTFOUND][toc]

Если во время цикла `INTERPRET` не будет
найдено очередное слово из входного потока - в текущем словаре ищется и
вызывается слово `NOTFOUND ( a u -- )`. Если `NOTFOUND` не обрабатывает данное
слово - он должен вывалиться с исключением. Иначе считается, что слово
воспринято и трансляция продолжается. По умолчанию через `NOTFOUND` реализовано
распознавание чисел, и доступ к вложенным словарям в виде:

	vocname1:: wordname

Правило хорошего тона - при переопределении `NOTFOUND` сначала вызвать его
старый вариант, и если он не отвалится по исключению - выполнять свои
действия. Пример:

	 : MY? ( a u -- ? ) S" !!" SEARCH >R 2DROP R> ;
	 : DO-MY ( a u -- ) ." My NOTFOUND: " TYPE CR ;

	 : NOTFOUND ( a u -- )
	   2DUP 2>R ['] NOTFOUND CATCH 
	   IF
	     2DROP
	     2R@ MY? IF 2R@ DO-MY ELSE -2003 THROW THEN
	   THEN
	   RDROP RDROP
	   ;
Или так:

	 : NOTFOUND ( a u -- )
	   2DUP MY? IF DO-MY EXIT THEN
	   ( a u )
	   NOTFOUND
	   ;


----
<a id="scatcoln"/>
###[Scattered colons][toc]

Расширяемые слова (описание техники: "[Scattering a Colon Definition][scatter]", на английском языке). 
Позволяют уже после определения слова добавлять в него новые действия.

	: INIT ... do1 ; 
	\ если вызвать INIT здесь то выполнится do1
	..: INIT do2 ;.. 
	\ если здесь - то do1 и do2 именно в таком порядке
	..: INIT do3 ;.. 
	\ и так далее

Подобного эффекта можно добиться и с помощью векторов, но так намного удобнее.

Через scattered colons в SPF реализованы слова `AT-THREAD-STARTING` и
`AT-PROCESS-STARTING`, которые вызываются при старте потока и при старте
процесса соответственно. Например библиотека `lib\include\float2.f` добавляет в
`AT-THREAD-STARTING` действия по инициализации внутренних переменных.

[scatter]: http://www.forth.org.ru/~mlg/ScatColn/ScatteredColonDef.html

----
<a id="task"/>
###[Многозадачность][toc]

Потоки создаются словом `TASK: ( xt -- task)` и запускаются словом 
`START ( u task -- tid )`, 
`xt` это исполнимый токен который получит управление при старте потока и
на стеке будет пользовательский параметр `u`. Возвращаемое значение `tid`
используется для остановки потока снаружи словом `STOP ( tid -- )`.
Приостановить поток на заданное время можно словом `PAUSE ( ms -- )`.
Пример:

	REQUIRE { lib/ext/locals.f

	:NONAME { u \ -- }
	   BEGIN
	   u .
	   u 10 * 100 + PAUSE
	  AGAIN
	; TASK: thread
	
	: go
	  10 0 DO I thread START LOOP
	  2000 PAUSE
	  ( tid1 tid2 ... tid10 )
	  10 0 DO STOP LOOP
	;

	go

Обычные переменные (`VARIABLE`, `VALUE`) будут разделять своё значение между
потоками. Если же переменная должна быть локальной для потока - следует
определять её словом `USER ( "name" -- )` или `USER-VALUE ( "name" -- )`.
USER-переменные при старте потока инициализируются нулём.


----
<a id="voc"/>
###[Словари][toc]

Словари создаются либо стандартным `VOCABULARY ( "name" -- )` 
либо словом `WORDLIST ( -- wid )`. 
Точнее, `WORDLIST` это более общее понятие - просто список слов. Есть
также слово `TEMP-WORDLIST ( -- wid)` создающее временный словарь, который по
окончании работы надо освободить из памяти словом `FREE-WORDLIST`, содержимое
временного словаря не попадёт в образ системы при использовании слова `SAVE`.
Слово `{{ ( "name" -- )` сделает словарь name контекстным, а слово `}}` вернёт как
было. Пример:

	MODULE: my
	: + * ;
	;MODULE
	{{ my 2 3 + . }}
напечатает 6, а не 5.


[toc]: #toc

----
----

<title>Особенности SPF</title>
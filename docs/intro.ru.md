<a id="start"/>

Особенности [SPF](readme.ru.html)
=================================

<title>Особенности SPF</title>

<i>Краткое вступление для тех, кто уже знаком с какой-либо Форт-системой и
стандартом ANS'94.</i>

<small>Последнее обновление: $Date$</small>

<!-- $Revision$ -->

----

[[Русский](intro.ru.html)] [[Английский](intro.en.html)]

----

##Содержание

* [Установил SPF4. И где здесь что-куда?](#devel)
* [Оптимизатор](#opt)
* [Поддержка ANS](#ans)
* [Как запускать и подключать файлы?](#include)
* [REQUIRE](#require)
* [Пути поиска файлов для INCLUDED](#included-path)
* [Модули](#module)
* [Регистро-зависимость](#case)
* [Ввод чисел](#numbers)
* [Структуры](#struct)
* [Где FORGET?](#forget)
* [Как одним словом очистить стек?](#cls)
* [Средства отладки](#debug)
* [Комментарии](#comments)
* [Строки](#string)
* [Генерация исполняемых модулей (exe-файлов)](#save)
* [Локальные и временные переменные](#locals)
* [Подключение dll-библиотек](#dll)
* [Слово NOTFOUND](#notfound)
* [Scattered colons](#scatcoln)
* [Многозадачность](#task)
* [Словари](#voc)
* [Указание области видимости](#doublecolon)


----
<a id="devel"/>
###[Установил SPF4. И где здесь что-куда?][start]

Первое и самое важное - расположение ваших рабочих файлов. В дистрибутиве SPF
есть каталог DEVEL, предназначенный для разработчиков (в том числе и вас).
Создайте в ней ваш подкаталог, например, ~vasya. И теперь вы можете подключать ваши
файлы написав сокращённый путь в виде `~vasya\prog\myprog.f`. Это упрощает
взаимный доступ к библиотекам и программам. Общепринято библиотеки класть в
подкаталог lib, а примеры программ в prog.

В каталоге DEVEL собраны наработки других SP-Forth'еров, с кратким (очень
кратким) их обзором вы можете ознакомиться в 
[SPF_DEVEL](devel.ru.html), либо пройтись по файлам самому.

В каталоге `samples/win/spfwc` вы найдёте GUI фронтенд для SPF. Просто
запустите `compile.bat` и скопируйте полученный бинарный файл `spf4wc.exe` в
корневой каталог установки (рядом с `spf4.exe`). 


----
<a id="opt"/>
###[Оптимизатор][start]

SPF - форт-система с подпрограммным шитым кодом, то есть компиляция проходит
сразу в исполняемый код в виде цепочек `CALL <адрес-cfa-слова>`. Этот код можно
запускать и непосредственно, но в системе по-умолчанию есть ещё и оптимизатор, 
который обрабатывает машкод для большего быстродействия, выполняя
inline-подстановку и peephole-оптимизацию. Подробнее на ForthWiki:
"[Оптимизирующий компилятор](http://wiki.forth.org.ru/оптимизирующий%20компилятор)".

**Управление оптимизатором** *(значения по умолчанию работают в подавляющем
большинстве случаев, вам скорее всего не нужны эти опции!)*

* `DIS-OPT` отключает макрооптимизацию
* `SET-OPT` включает макрооптимизацию (по-умолчанию включена)
* `0 TO MM_SIZE` отключает inline подстановку оптимизатора (помните что inline
   подстановка для `DO` `LOOP` и некоторый других слов выполняется ядром spf и не зависит от этой опции)
* `TRUE TO ?C-JMP` включает оптимизацию хвостовой рекурсии (экспериментальная,
   по-умолчанию выключена, иногда глючит) 

**NB**: Если вдруг ваша программа начинает выкидывать неожиданные фортели -
отключите временно оптимизацию словом `DIS-OPT`, есть вероятность (очень
маленькая!), что это может быть ошибка в оптимизаторе. Если это так -
локализуйте её и напишите пожалуйста багрепорт.

Результат компиляции слова в виде машинного кода можно посмотреть вручную с
помощью дизассемблера:

	REQUIRE SEE lib/ext/disasm.f
	SEE слово

или получить построчный листинг (форт-код и соответствующий машкод)

	REQUIRE INCLUDED_L ~mak/listing2.f
	S" файл, машкод которого хотим посмотреть"  INCLUDED_L
	\ листинг будет лежать рядом с подключаемым файлом


----
<a id="ans"/>
###[Поддержка ANS][start]

Максимального соответствия ANS'94 можно добиться подключив
`lib/include/ansi.f`. Там определяются дополнительные наборы слов, некоторые
заглушки и т. д.

Также исправляется нарушающая стандарт оптимизация слов из ядра для 
работы с файлами - `OPEN-FILE`, `CREATE-FILE` и другие неявно 
требуют строку оканчивающуюся нулём, тогда как стандарт этого не 
требует. `lib/include/ansi-file.f` при получении строки без нуля в конце 
самостоятельно добавляет нулевой байт. При этом имя файла копируется во 
временный динамический буфер, который остаётся неосвобожденным для последующего 
использования. При явном указании имени файла с помощью строчных литералов `S"`
и строчных библиотек `~ac/lib/str*.f` необходимости в этом исправлении нет, 
т.к. строки всегда заканчиваются нулем. Но при использовании не-SPF-библиотек 
это может пригодиться.


----
<a id="include"/>
###[Как запускать и подключать файлы?][start]

В командной строке скормить файл SPF'у можно просто указав путь к нему в
параметрах запуска, 

	spf.exe ~vasya/prog/myprog.f
Заметьте, что путь для включения могут быть как абсолютным, так и
относительно каталога [devel](#devel).

В консоли SPF (в режиме интерпретации) достаточно набрать имя файла:

	~vasya/prog/myprog.f
В целях совместимости лучше подключать явно:

	S" ~vasya/prog/myprog.f" INCLUDED

Но правильнее всего использовать `REQUIRE`.


----
<a id="require"/>
###[REQUIRE][start]

В SPF есть нестандартное слово `REQUIRE ("word" "file" -- )`, где `word` -
некоторое слово определённое в библиотеке `file`. Если слово `word` присутствует в 
контекстном словаре, `REQUIRE` считает, что библиотека уже была подключена и не загружает её.
Так избегается двойная загрузка библиотек.
Если же найти `word` не удаётся - библиотека подключается обычным образом
(через `INCLUDED`).
Например:

	REQUIRE CreateSocket ~ac/lib/win/winsock/sockets.f
	REQUIRE ForEach-Word ~pinka/lib/words.f
	REQUIRE ENUM ~nn/lib/enum.f

**NB:** В качестве `word` выбирайте всегда наиболее уникальное слово из
подключаемой библиотеки.


----
<a id="included-path"/>
###[Пути поиска файлов для INCLUDED][start]

`S" file.f" INCLUDED` будет искать в перечисленных ниже местах в именно таком порядке

* короткое имя файла `file.f` (т.е. в текущем каталоге)
* `PATH_TO_SPF.EXE\devel\file.f` (т.о. удобно использовать чужие наработки), 
* `PATH_TO_SPF.EXE\file.f` (так подключаются стандартные либы и другие файлы из поставки SPF). 

Если требуется указать больше путей поиска (например использовать форт код разделяемый между
системами, или неважно - любой код вне дерева каталогов SPF который не может быть адресован
относительно текущего файла), то можно либо переопределить `FIND-FULLNAME` (который `VECT`) 
либо использовать внешнюю либу - `~ygrek/spf/included.f`.

**TODO:** Вынести отдельно

 Тогда потребуется только прописать в spf4.ini

	~ygrek/spf/included.f
	with: my_path\
	S" my path with spaces/" with

и все файлы будут искаться в `my_path` в дополнение к описанному выше алгоритму
(`my_path` может быть как абсолютным так и относительно spf.exe). 


----
<a id="module"/>
###[Модули][start]

В SPF есть модули, которые позволяют скрывать некоторые внутренние слова
библиотек выводя наружу только слова для взаимодействия.

	MODULE: vasya-lib
	\ внутренние слова
	EXPORT
	\ слова взаимодействия, видные снаружи, компилируются во внешний словарь.
	DEFINITIONS
	\ опять внутренние слова
	EXPORT
	\ ну вы поняли :)
	;MODULE
Код `MODULE: vasya-lib` можно писать много раз - последующие вызовы будут
докомпилировать слова в тот же модуль. На самом деле слово определённое через
`MODULE:` это обычный [словарь](#voc).


----
<a id="case"/>
###[Регистро-зависимость][start]

SPF регистрозависим, то есть в этом режиме для него слова `CHAR` , `Char` и `char` -
три разных слова. Этот режим можно выключить подключением файла
`lib/ext/caseins.f`.



----
<a id="numbers"/>
###[Ввод чисел][start]

SPF позволяет вводить шестнадцатеричные числа вне зависимости от текущей системы
счисления (значения переменной `BASE`) так:
 
	0x7FFFFFFF
Вещественные числа можно вводить в формате `[+|-][dddd][.][dddd]e[+|-][dddd]`
подключив либу `lib\include\float2.f`.


----
<a id="struct"/>
###[Структуры][start]

Структуры в SPF создаются через слово `--` (оно же `FIELD`). Пример:

	0
	CHAR -- flag
	CELL -- field
	10 CELLS -- arr
	CONSTANT struct

Слова `flag`, `field` и `arr` будут прибавлять к адресу своё смещение 
относительно начала структуры. А в `struct` записан общий размер
всей структуры. То есть, можно:

	struct ALLOCATE THROW TO s \ взяли память из кучи под один экземпляр struct
	1 s flag С!  10 s field ! \ записали значения в поля структуры
	s arr 10 CELLS DUMP \ вывели содержимое массива в структуре
	s FREE THROW \ сняли экземпляр struct

Структуры можно наследовать:

	0
	CELL -- x
	CELL -- y
	CONSTANT point \ у point два поля
	
	point
	CELL -- radius
	CONSTANT circle \ у circle три поля: x, y, radius
	
	point
	CELL -- w
	CELL -- h
	CONSTANT rect \ у rect четыре поля: x, y, w, h

----
<a id="forget"/>
###[Где FORGET?][start]

`FORGET` нет. Но есть `MARKER ( "name" -- )` (в `lib\include\core-ext.f`).



----
<a id="cls"/>
###[Как одним словом очистить стек?][start]

Наберите `lalala`. Или `bububu`. Или `лялятополя`. Возникнет ошибка и стек сбросится.
На самом деле стек сбросит слово `ABORT`, которое будет вызвано если интерпретатор
не найдёт введённое слово. Ну а на самом-самом деле - это делается так: `S0 @ SP!`


----
<a id="debug"/>
###[Средства отладки][start]

Слово `STARTLOG` включает запись всего консольного вывода в лог-файл
`spf.log` в текущем каталоге. `ENDLOG` соответственно выключает такое поведение.

[Больше средств в devel](devel.ru.html#debug)


----
<a id="comments"/>
###[Комментарии][start]

В SPF есть комментарий до конца строки ` \ `. Есть и обычные, скобочные, комментарии,
которые к тому же ещё и многострочные. То есть:

	\ комментарий до конца строки
	( комментарий
	и даже в несколько строк )
Есть слово `\EOF` которое делает комментарием всё идущее после него в файле. Таким
образом удобно отделять примеры использования библиотеки от самой библиотеки.

	word1 word2
	\EOF
	комментарий до конца файла



----
<a id="string"/>
###[Строки][start]

В SPF в основном используются строки со счётчиком на стеке - т.е. два значения
`(addr u)`. Для записи строковых литералов (строковых констант) используется
слово `S"`, которое в зависимости от текущего режима выполняет несколько разные
действия:

* В режиме интерпретации строка находится во временном текстовом буфере разбора (`TIB`),
и соответственно, работает только в пределах одной строки.

* В режиме компиляции строка вкомпилируется непосредственно в шитый код определяемого слова.

**NB**: В память после символов строки добавляется один нулевой байт, в
счётчике символов он не учитывается - это сделано для удобства работы с функциями WinAPI.

Слово `S"` создаёт т. н. статическую строку, она находится или в буфере, или в словарной
структуре SPF. Для работы со динамическими строками, которые резервируются в "куче" и снимаются
оттуда есть библиотека `~ac\lib\str5.f`. Пример её использования:

	REQUIRE STR@ ~ac/lib/str5.f
	"" VALUE r \ создаём пустую строку
	" мама, мама, " VALUE m
	" что я буду делать?" VALUE w
	m r S+  w r S+
	r STYPE
	> мама, мама, что я буду делать?

Кроме конкатенации строк можно использовать и подстановку (в том числе и других строк):

	" 2+2={2 2 +}" STYPE
	> 2+2=4

Исчерпывающее описание и более подробные примеры см. в самой библиотеке.

Надо также заметить что в SPF поддерживается префикс слов `S-` и окончание `-ED`.

`S-` означает что слово работает со строками со счётчиком (например есть
`SFIND` и есть стандартный `FIND`, есть `SLITERAL` и `LITERAL`).

`-ED` есть в словах `CREATED`, `INCLUDED`, `REQUIRED`, `ALIGNED`. Он обозначает что это
слово, в отличии от своего "корня", будет ожидать параметров со стека, а не брать его из
входного потока (или из глобальной переменной, как в случае с `ALIGN` и `ALIGNED`).

Например, стандартный `CREATE` берёт свой параметр из входного потока, тогда как `CREATED`
явно забирает параметр со стека данных в виде начала строки и её длины.

----
<a id="save"/>
###[Генерация исполняемых модулей (exe-файлов)][start]

Слово `SAVE ( a u -- )` сохраняет всю форт-систему, включая все словарные
структуры (кроме временных!) в исполняемый модуль путь к которому задаётся
строкой `a u`. Точка входа определяется value-переменной `<MAIN>` для
консольного режима и переменной `MAINX` для GUI. Режим определяется
value-переменными `?CONSOLE` и `?GUI`. `SPF-INIT?` контролирует интерпретацию
командной строки и подключение spf4.ini:

	0 TO SPF-INIT?
	' ANSI>OEM TO ANSI><OEM
	TRUE TO ?GUI
	' NOOP TO <MAIN>
	' run MAINX !
	S" gui.exe" SAVE  

или

    ' run TO <MAIN>
	S" console.exe" SAVE


----
<a id="locals"/>
###[Локальные и временные переменные][start]

Не входят в ядро, но подключаются:

	REQUIRE { lib/ext/locals.f
	
	\ пример простого использования
	: test { a b | c d }  \ a b инициализируются со стека, c и d нулями
	  a TO c
	  b TO d
	  c . d . ;
	1 2 test
	>1 2
	> Ok
Подробное описание и примеры использования смотрите в самой библиотеке.



----
<a id="dll"/>
###[Подключение dll-библиотек][start]

Для функций использующих формат вызова stdcall (например Win32 API) :

	WINAPI: SevenZip 7-zip32.dll
Для формата вызова cdecl (например msvcrt.dll) и функций с переменным числом
параметров используйте :

	REQUIRE CAPI: ~af/lib/c/capi.f
    2 CAPI: strstr msvcrt.dll
Если нужно подключить все функции из dll-файла то можно использовать для
stdcall :

	REQUIRE UseDLL ~nn/lib/usedll.f
	UseDLL "имя_библиотеки"
или:

	REQUIRE DLL ~ac/lib/ns/dll-xt.f
	DLL NEW: "имя_библиотеки" 
Для cdecl :

	REQUIRE USES_C ~af/lib/c/capi-func.f
	USES_C "имя_библиотеки"
или:

	REQUIRE SO ~ac/lib/ns/so-xt.f
	SO NEW: "имя_библиотеки"


----
<a id="notfound"/>
###[Слово NOTFOUND][start]

Если во время цикла `INTERPRET` не будет
найдено очередное слово из входного потока - в текущем словаре ищется и
вызывается слово `NOTFOUND ( a u -- )`. Если `NOTFOUND` не обрабатывает данное
слово - он должен вывалиться с исключением. Иначе считается, что слово
воспринято и трансляция продолжается. По умолчанию через `NOTFOUND` реализовано
распознавание чисел, и доступ к вложенным словарям в виде:

	vocname1:: wordname

Правило хорошего тона - при переопределении `NOTFOUND` сначала вызвать его
старый вариант, и если он не отвалится по исключению - выполнять свои
действия. Пример:

	 : MY? ( a u -- ? ) S" !!" SEARCH >R 2DROP R> ;
	 : DO-MY ( a u -- ) ." My NOTFOUND: " TYPE CR ;

	 : NOTFOUND ( a u -- )
	   2DUP 2>R ['] NOTFOUND CATCH 
	   IF
	     2DROP
	     2R@ MY? IF 2R@ DO-MY ELSE -2003 THROW THEN
	   THEN
	   RDROP RDROP
	   ;
Или так:

	 : NOTFOUND ( a u -- )
	   2DUP MY? IF DO-MY EXIT THEN
	   ( a u )
	   NOTFOUND
	   ;


----
<a id="scatcoln"/>
###[Scattered colons][start]

Расширяемые слова (описание техники: "[Scattering a Colon
Definition][scatter]", на английском языке). Позволяют уже после определения
слова добавлять в него новые действия. Слово `...` подготавливает место 
для будущего расширения. `..:` и `;..` добавляют действие как расширение.

	: INIT ... orig ; 
	\ если вызвать INIT здесь то выполнится orig
	..: INIT extend1 ;.. 
	\ если здесь - то extend1 и orig именно в таком порядке
	..: INIT extend2 ;.. 
	\ эквивалентно : INIT extend1 extend2 orig ;
	\ и так далее

Подобного эффекта можно добиться и с помощью векторов, но так намного удобнее.

Через scattered colons в SPF реализованы слова `AT-THREAD-STARTING` и
`AT-PROCESS-STARTING`, которые вызываются при старте потока и при старте
процесса соответственно. Например библиотека `lib\include\float2.f` добавляет в
`AT-THREAD-STARTING` действия по инициализации внутренних переменных.

[scatter]: http://www.forth.org.ru/~mlg/ScatColn/ScatteredColonDef.html

----
<a id="task"/>
###[Многозадачность][start]

Потоки создаются словом `TASK: ( xt -- task)` и запускаются словом 
`START ( u task -- tid )`, 
`xt` это исполнимый токен который получит управление при старте потока и
на стеке будет пользовательский параметр `u`. Возвращаемое значение `tid`
используется для остановки потока снаружи словом `STOP ( tid -- )`.
Приостановить поток на заданное время можно словом `PAUSE ( ms -- )`.
Пример:

	REQUIRE { lib/ext/locals.f

	:NONAME { u \ -- }
	   BEGIN
	   u .
	   u 10 * 100 + PAUSE
	  AGAIN
	; TASK: thread
	
	: go
	  10 0 DO I thread START LOOP
	  2000 PAUSE
	  ( tid1 tid2 ... tid10 )
	  10 0 DO STOP LOOP
	;

	go

Обычные переменные (`VARIABLE`, `VALUE`) будут разделять своё значение между
потоками. Если же переменная должна быть локальной для потока - следует
определять её словом `USER ( "name" -- )` или `USER-VALUE ( "name" -- )`.
USER-переменные при старте потока инициализируются нулём.


----
<a id="voc"/>
###[Словари][start]

Словари создаются либо стандартным `VOCABULARY ( "name" -- )` 
либо словом `WORDLIST ( -- wid )`. 
Точнее, `WORDLIST` это более общее понятие - просто список слов. Есть
также слово `TEMP-WORDLIST ( -- wid)` создающее временный словарь, который по
окончании работы надо освободить из памяти словом `FREE-WORDLIST`, содержимое
временного словаря не попадёт в образ системы при использовании слова `SAVE`.
Слово `{{ ( "name" -- )` сделает словарь name контекстным, а слово `}}` вернёт как
было. Пример:

	MODULE: my
	: + * ;
	;MODULE
	{{ my 2 3 + . }}
напечатает 6, а не 5.

[start]: #start

----
<a id="doublecolon"/>
###[Указание области видимости][start]

Слова SPF и сопутствующих ему библиотек распределяются по разным словарям. Главные слова, слова взаимодействия лексикона задаются в главном словаре `FORTH`, слова внутренние и/или те которые нуждаются в упрятывании -- в отдельных для каждого лексикона словарях (см. также <a href=#modules>модули</a>).

В тех случаях когда нужно вызвать внутреннее слово реализации из словаря/модуля используется синтаксис вида `WORDLIST::word` (при этом должно быть понимание, что лезть во внутренние детали лексиконов в обход предусмотренных автором слов взаимодействия -- это в общем-то, не очень хорошо). Пример:

	MODULE: someWords
	: someInternalWord ." bla-bla" ;
	;MODULE
	
	someWords::someInternalWord

Есть также случаи когда нужно разрешить неоднозначность выбора между несколькими словами с одинаковым именем определённых в разных словарях. Точнее говоря неоднозначности-то нет, просто SPF может решать её не так, как хотелось бы нам. Пример:

	MODULE: someWords
	: TYPE 2DROP ;
	;MODULE
	
	ALSO someWords \ добавляем словарь superWords в контекст
	S" foo" TYPE \ ничего не выводится, берётся TYPE из superWords
	S" bar" FORTH::TYPE \ явное указание "обычного" TYPE из главного словаря

Для выполнения неких действий над словами через `'` (взятие xt слова), `POSTPONE` (компилирование), `TO` (для выполнения вторичного действия слова) область видимости нужно указывать в первом слове: `WORDLIST::' word`, `WORDLIST::POSTPONE word` и т.д.
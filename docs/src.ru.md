<a id="start"/>

Устройство [SPF](readme.ru.html)
================================

<title>Устройство SPF</title>

<i>Детали реализации ядра</i>

<small>Последнее обновление: $Date$</small>

<!-- $Revision$ -->

----

<!-- [[Английский](src.en.html)] --> [[Русский](src.ru.html)] 

----

##Содержание

* [Распределение регистров](#regs)
* [Стеки](#stack)
* [Хранилище](#image)
* [Динамическая память](#heap)
* [Словарная статья](#article)
* [Перекомпиляция ядра](#make-kernel)
* [Макрооптимизатор](#macroopt)

----
<a id="regs"/>
###[Распределение регистров](#regs)

* EAX - вершина стека данных
* EBP - указатель на стек данных (т.е. [EBP] - второй элемент стека данных)
* ESP - указатель на стек возвратов
* EDI - указатель на данные потока (указывает на начало USER-области текущего потока)

----
<a id="stack"/>
###[Стеки](#stack)

Стек возвратов совмещен с аппаратным стеком (ESP).
Стек параметров адресуется регистром EBP, вершина стека хранится в EAX

Указатели стеков: `SP@` `RP@` `SP!` `RP!`

Дно стеков: `S0` `R0` 

Оба стека начиная от своего дна, растут вниз (в сторону уменьшения адресов).

( `src/compiler/spf_translate.f` )

----
<a id="image"/>
###[Хранилище](#image)

Контекст (`ORDER`, `CURRENT`) у каждого потока свой
(по умолчанию: `ONLY FORTH DEFINITIONS` ).
Поддерживается параллельная интерпретация.

Компиляция в одно хранилище должна осуществляться только одним потоком (во избежание).

Код и данные хранятся в едином хранилище (сегменте, кодофайле).
Слова доступа к нему стандартные : `HERE` `ALLOT` `,` `C,`
Слово `UNUSED` вынесено в `lib/include/core-ext.f`

<img src="images/src_static.png"/>

`IMAGE-BASE` - начало хранилища.

`IMAGE-SIZE` - резервируемый размер.

Временные словари (  `TEMP-WORDLIST`  `FREE-WORDLIST` ).
Такой словарь ассоциирован с собственным хранилищем
(память для которого распределяется динамически).

Когда такой словарь (список) является текущим (`CURRENT`)
(словарем компиляции, целевым, в который добавляются слова)
`HERE` дает начало свободной области его хранилища.


----
<a id="heap"/>
###[Динамическая память](#heap)

<img src="images/src_heap.png"/>

*Windows:* У каждого потока свой хип. `ALLOCATE` выделяет память из хипа потока, в контексте 
которого вызвано. При завершении потока его хип уничтожается (вся память выделенная 
из этого хипа -- освобождается).

*Linux:* Отдельных хипов нет. **FIXME** Надо ли синхронизировать ALLOCATE?

Хип процесса ядром форт-системы не используется.
(хотя в принципе, его можно использовать, и некоторые расширения делают это).

*Windows:* При доступе к разделяемому хипу из разных потоков стоит вспомнить о необходимости синхронизации.

Кроме отдельной кучи каждый поток имеет свой собственный блок статических данных
-- USER-область (размером `EXTRA-MEM`, по-умолчанию 8кб). Переменные и массивы 
резервируются там словами словами `USER` , `USER-VALUE` .


----
<a id="article"/>
###[Словарная статья](#article)

Словарь является односвязным списком с полем имени (его адрес обозначаемый как NFA 
используется для идентификации конкретной словарной статьи в словаре), полем кода 
в котором хранится `xt` действия данного слова, полем флагов (содержит признаки 
характеризующие это слово -- `&IMMEDIATE` и `&VOC` )

<img src="images/src_voc.png"/>

Т. н. "поля параметров" нет, так как "телом" определений в SPF являются последовательности
машинных инструкций.

( `src/compiler/spf_wordlist.f` )


----
<a id="make-kernel"/>
###[Перекомпиляция ядра](#make-kernel)

**FIXME** перенести в intro

В файле `src/spf_compileoptions.f` описаны параметры компиляции по умолчанию которые можно 
переопределить в `src/compile.ini`.

*Windows:* Компиляция ядра выполняется запуском bat-файла `src/compile.bat`. По умолчанию, 
сборку выполняет одна их младших версий SPF (jpf375c.exe в корневой папке), но
SPF может и сам собирать себя. 

*Linux:* Для перекомпиляции ядра можно использовать `src/compile` или `src/Makefile`. Во время
сборки компилируется и выполняется программа на Си которая генерирует `src/posix/config.auto.f` с
определениями системно-зависимых констант. Целевой компилятор создаёт объектный файл, который потом
линкуется с системными библиотеками (libdl, libc, libpthread). В `src/compile.ini` необходимо вписать :

    TRUE TO TARGET-POSIX
    TRUE TO UNIX-ENVIRONMENT
    FALSE TO USE-OPTIMIZER
    FALSE TO BUILD-OPTIMIZER \ т.к. оптимизатор в spf/linux не работает (временно).   

----
<a id="macroopt"/>
###[Макрооптимизатор](#macroopt)

Макрооптимизатор подключается два раза :

* в инструментальную систему, используется в процессе сборки для оптимизации кода целевой
  (создаваемой) системы, подключается в `src/tc_spf.F` (USE-OPTIMIZER)
* в целевую систему, для того чтобы новая система во время исполнения генерировала оптимизированный
  код, подключается в `src/spf.f` (BUILD-OPTIMIZER)

**FIXME** Описание переменных из macroopt.f которые используются в ядре. **HELP PLEASE**

----

<a id="start"/>

[SPF](readme.en.html) ANS support
=================================

<title>SPF ANS support</title>

<i>Documentation for implementation-specific issues of the ANS standard as required
by section {std 4.}</i>

<small>Last update: $Date$</small>

----

[[Russian](ans.ru.html)] [[English](ans.en.html)]

----

##Contents

* [qqq](#qqq)
* [Implementation-defined options](#impl)
* [Ambigous conditions](#amb)
* [Other system documentation](#other)

----
<a id="qqq"/>
###[qqq](#qqq)

Maximum ANS conformity is achieved by including `lib/include/ansi.f`.
Additional words are defined, some of them dummies, etc. 

Also, a non-standard optimization of FILE wordset is fixed - `OPEN-FILE`,
`CREATE-FILE` and other implicitly treat the input string as zero-ended (ignoring the
length parameter). `lib/include/ansi-file.f` will add an extra zero byte in
such case, after copying the file name to the dynamic buffer, which remains
allocated for future use. You don't really need such behaviour when
defining file names with string literal `S"` or string libraries
`~ac/lib/str*.f`, as they ensure there is an extra zero byte. Though it can be
helpful for using non-SPF libraries.

----
<a id="impl"/>
###[Implementation-defined options](#impl)

* aligned address requirements ({std 3.1.3.3} Addresses); 

* behavior of {std 6.1.1320} EMIT for non-graphic characters;
  
  `TYPE` and `EMIT` fully depend on the OS API for handling special chracters,
  on Windows this results in performing special assigned actions such as Line
  Feed, Carriage Return, Beep etc

* character editing of {std 6.1.0695} ACCEPT and {std 6.2.1390} EXPECT;

  `EXPECT` is not available (obsolete). `ACCEPT` fully depends on the
  capabilities of the shell. On Windows by default it provides command history
  and convenient one line editing with arrows, Ins, Del, Bksp etc

* character set ({std 3.1.2} Character types, {std 6.1.1320} EMIT, {std 6.1.1750} KEY); 

* character-aligned address requirements ({std 3.1.3.3} Addresses); 

  No requirements are imposed. Character aligned data can start at any address.

* character-set-extensions matching characteristics ({std 3.4.2} Finding definition names); 

* conditions under which control characters match a space delimiter ({std 3.4.1.1} Delimiters); 

  Parser treats all characters with the ascii code less than 32 (`BL`) as
  delimiters. This doesn't depend on the input source.

* format of the control-flow stack ({std 3.2.3.2} Control-flow stack); 

  Control flow stack is available and implemented using the data stack.
  Separate control flow stack implementation is available as an extension
  `~mak/lib/a_if.f`.

* conversion of digits larger than thirty-five ({std 3.2.1.2} Digit conversion); 

  SPF converts digits according to the character table, so `50 BASE ! a 0[ DECIMAL . .` 
  will produce `36 42`.

* display after input terminates in {std 6.1.0695} ACCEPT and {std 6.2.1390} EXPECT; 

  Depends on the shell, by default the input is echoed while typing and
  remains on the screen at the same position when input is finished, with
  additional carriage return.

* exception abort sequence (as in {std 6.1.0680} ABORT");

* input line terminator ({std 3.2.4.1} User input device); 

  Input line is terminated with the sequence of two characters CRLF (ASCII codes
  hex 0D 0A). `UNIX-LINES` switches to LF (ASCII hex 0x0A), `DOS-LINES` restores
  default behavior. Internal variable that holds the terminator sequence is
  LT and the length of the sequence is stored in LTL, thus `LT LTL @ ( a u )`.

* maximum size of a counted string, in characters ({std 3.1.3.4} Counted strings, {std 6.1.2450} WORD); 

  255 characters

* maximum size of a parsed string ({std 3.4.1} Parsing); 

  255 characters ?

* maximum size of a definition name, in characters ({std 3.3.1.2} Definition names); 

  255 characters ?

* maximum string length for {std 6.1.1345} ENVIRONMENT?, in characters; 

  MAX-INT

* method of selecting {std 3.2.4.1} User input device; 

* method of selecting {std 3.2.4.2} User output device; 

* methods of dictionary compilation ({std 3.3} The Forth dictionary); 

* number of bits in one address unit ({std 3.1.3.3} Addresses); 

* number representation and arithmetic ({std 3.2.1.1} Internal number representation); 

* ranges for n, +n, u, d, +d, and ud (3.1.3 Single-cell types, 3.1.4 Cell-pair types); 

* read-only data-space regions (3.3.3 Data space); 

* size of buffer at 6.1.2450 WORD (3.3.3.6 Other transient regions); 

* size of one cell in address units (3.1.3 Single-cell types); 

* size of one character in address units (3.1.2 Character types); 

* size of the keyboard terminal input buffer (3.3.3.5 Input buffers); 

* size of the pictured numeric output string buffer (3.3.3.6 Other transient regions); 

* size of the scratch area whose address is returned by 6.2.2000 PAD (3.3.3.6 Other transient regions); 

* system case-sensitivity characteristics (3.4.2 Finding definition names); 

  SPF kernel is case sensitive. Extension `lib/ext/caseins.f` replaces
  `SEARCH-WORDLIST` to perform  case-insensitive search.

* system prompt ({std 3.4} The Forth text interpreter, {std 6.1.2050} QUIT); 

  None ?

* type of division rounding ({std 3.2.2.1} Integer division, {std 6.1.0100} */, {std 6.1.0110} */MOD, {std 6.1.0230} /, {std 6.1.0240} /MOD, {std 6.1.1890} MOD); 

  ?

* values of {std 6.1.2250} STATE when true; 

  ?

* values returned after arithmetic overflow ({std 3.2.2.2} Other integer operations); 

* whether the current definition can be found after {std 6.1.1250} DOES> ({std 6.1.0450} :). 

----
<a id="amb"/>
###[Ambiguous conditions](#amb)

* a name is neither a valid definition name nor a valid number during text interpretation ({std 3.4} The Forth text interpreter); 

* a definition name exceeded the maximum length allowed ({std 3.3.1.2} Definition names); 

* addressing a region not listed in {std 3.3.3} Data Space; 

* argument type incompatible with specified input parameter, e.g., passing a flag to a word expecting an n ({std 3.1} Data types); 

* attempting to obtain the execution token, (e.g., with {std 6.1.0070} ', {std 6.1.1550} FIND, etc.) of a definition with undefined interpretation semantics; 

* dividing by zero ({std 6.1.0100} */, {std 6.1.0110} */MOD, {std 6.1.0230} /, {std 6.1.0240} /MOD, {std 6.1.1561} FM/MOD, {std 6.1.1890} MOD, {std 6.1.2214} SM/REM, {std 6.1.2370} UM/MOD, {std 8.6.1.1820} M*/); 

* insufficient data-stack space or return-stack space (stack overflow); 

* insufficient space for loop-control parameters; 

* insufficient space in the dictionary; 

* interpretating a word with undefined interpretation semantics; 

* modifying the contents of the input buffer or a string literal ({std 3.3.3.4} Text-literal regions, {std 3.3.3.5} Input buffers); 

* overflow of a pictured numeric output string; 

* parsed string overflow; 

* producing a result out of range, e.g., multiplication (using \*) results in a value too big to be represented by a single-cell integer ({std 6.1.0090} \*, {std 6.1.0100} \*/, {std 6.1.0110} \*/MOD, {std 6.1.0570} >NUMBER, {std 6.1.1561} FM/MOD, {std 6.1.2214} SM/REM, {std 6.1.2370} UM/MOD, {std 6.2.0970} CONVERT, {std 8.6.1.1820} M*/); 

* reading from an empty data stack or return stack (stack underflow); 

* unexpected end of input buffer, resulting in an attempt to use a zero-length string as a name; 



* \>IN greater than size of input buffer ({std 3.4.1} Parsing); 

* {std 6.1.2120} RECURSE appears after {std 6.1.1250} DOES>; 

* argument input source different than current input source for {std 6.2.2148} RESTORE-INPUT; 

* data space containing definitions is de-allocated ({std 3.3.3.2} Contiguous regions); 

* data space read/write with incorrect alignment ({std 3.3.3.1} Address alignment); 

* data-space pointer not properly aligned ({std 6.1.0150} ,, {std 6.1.0860} C,); 

* less than u+2 stack items ({std 6.2.2030} PICK, {std 6.2.2150} ROLL); 

* loop-control parameters not available ( {std 6.1.0140} +LOOP, {std 6.1.1680} I, {std 6.1.1730} J, {std 6.1.1760} LEAVE, {std 6.1.1800} LOOP, {std 6.1.2380} UNLOOP); 

* most recent definition does not have a name ({std 6.1.1710} IMMEDIATE); 

* name not defined by {std 6.2.2405} VALUE used by {std 6.2.2295} TO; 

* name not found ({std 6.1.0070} ', {std 6.1.2033} POSTPONE, {std 6.1.2510} ['], {std 6.2.2530} [COMPILE]); 

* parameters are not of the same type ({std 6.1.1240} DO, {std 6.2.0620} ?DO, {std 6.2.2440} WITHIN); 

* {std 6.1.2033} POSTPONE or {std 6.2.2530} [COMPILE] applied to {std 6.2.2295} TO; 

* string longer than a counted string returned by {std 6.1.2450} WORD; 

* u greater than or equal to the number of bits in a cell ({std 6.1.1805} LSHIFT, {std 6.1.2162} RSHIFT); 

* word not defined via {std 6.1.1000} CREATE ({std 6.1.0550} >BODY, {std 6.1.1250} DOES>); 

* words improperly used outside {std 6.1.0490} <# and {std 6.1.0040} #> ({std 6.1.0030} #, {std 6.1.0050} #S, {std 6.1.1670} HOLD, {std 6.1.2210} SIGN). 


----
<a id="other"/>
###[Other system documentation](#other)

* list of non-standard words using {std 6.2.2000} PAD ({std 3.3.3.6} Other transient regions); 

* operator's terminal facilities available; 

* program data space available, in address units; 

* return stack space available, in cells; 

* stack space available, in cells; 

* system dictionary space required, in address units. 
